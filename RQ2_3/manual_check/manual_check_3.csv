commitId,commitTime,diff,message,isImplicit
4d5d98c30ac9809b018cb5b5ad2118c9f16ffc87,2022-02-08 23:41:11-08:00,"mmm Registry . java <nl> ppp Registry . java <nl> - private static synchronized <KeyProtoT extends MessageLite, KeyFormatProtoT extends MessageLite> <nl> - void ensureKeyManagerInsertable( <nl> - String typeUrl, <nl> - Class<?> implementingClass, <nl> - Map<String, KeyTypeManager . KeyFactory . KeyFormat<KeyFormatProtoT>> keyFormats, <nl> - boolean newKeyAllowed) <nl> - throws GeneralSecurityException { <nl> - KeyManagerContainer container = keyManagerMap . get(typeUrl) ; <nl> - if (container != null && !container . getImplementingClass() . equals(implementingClass)) { <nl> - logger . warning(""Attempted overwrite of a registered key manager for key type "" + typeUrl) ; <nl> - throw new GeneralSecurityException( <nl> - String . <nl>",fix ungrouped overload lint error in registry.java,1
fa3fcc20764ad628f1055c243cb28e813844e543,2022-02-09 01:43:25-08:00,mmm PaymentMethodTokenSender . java <nl> ppp PaymentMethodTokenSender . java <nl> + public Builder recipientPublicKey(ECPublicKey val) throws GeneralSecurityException { <nl> + recipientPublicKey = val ; <nl> + return this ; <nl> + } <nl> - public Builder recipientPublicKey(ECPublicKey val) throws GeneralSecurityException { <nl> - recipientPublicKey = val ; <nl> - return this ; <nl> - } <nl> mmm GcpKmsClient . java <nl> ppp GcpKmsClient . java <nl> - GoogleCredential . fromStream( <nl> - new FileInputStream(new File(credentialPath))) ; <nl> + GoogleCredential . fromStream(new FileInputStream(new File(credentialPath))) ; <nl> + public KmsClient withCredentials(GoogleCredential credential) { <nl> + if (credential . createScopedRequired()) { <nl> <nl>,fix ungrouped overload lint error in java,1
03a3e528e985a0d666fac94180098853bdb58dde,2022-06-16 07:42:30-07:00,"mmm PrimitiveSet . java <nl> ppp PrimitiveSet . java <nl> + import javax . annotation . Nullable ; <nl> + @Nullable <nl> - private boolean isMutable ; <nl> + private final boolean isMutable ; <nl> + @Deprecated <nl> - private PrimitiveSet(MonitoringAnnotations annotations, Class<P> primitiveClass) { <nl> - this . primitives = new ConcurrentHashMap<>() ; <nl> - this . primitiveClass = primitiveClass ; <nl> - this . annotations = annotations ; <nl> - this . isMutable = true ; <nl> - } <nl> - public static <P> PrimitiveSet<P> newPrimitiveSet(Class<P> primitiveClass) { <nl> - return new PrimitiveSet<P>(primitiveClass) ; <nl> - } <nl>",deprecate mutable api of primitiveset,1
5f92a043d35e03ce4b81561220c71d550865fefa,2022-08-10 06:20:47-07:00,"mmm JwkSetConverter . java <nl> ppp JwkSetConverter . java <nl> - handle . writeNoSecret(new JwkSetWriter(outputStream)) ; <nl> + try { <nl> + handle . writeNoSecret(new JwkSetWriter(outputStream)) ; <nl> + } catch (IOException e) { <nl> + throw new GeneralSecurityException(e) ; <nl> + } <nl> - throw new IOException(""JWK set is invalid JSON"", ex) ; <nl> + throw new GeneralSecurityException(""JWK set is invalid JSON"", ex) ; <nl> - throw new IOException(""unexpected alg value: "" + getStringItem(jsonKey, ""alg"")) ; <nl> + throw new GeneralSecurityException( <nl> + ""unexpected alg value: "" getStringItem(jsonKey, ""alg"")) ; <nl> - throw new IOException(""empty keyset"") ; <nl> <nl>",do not throw ioexception in jwksetconverter,1
129b26a29f3ae8a4fd3b62b413653ff3f661f2f8,2022-10-18 02:06:56-07:00,mmm Registry . java <nl> ppp Registry . java <nl> + if (TinkFipsUtil . useOnlyFips()) { <nl> + return ; <nl> + } <nl> mmm RegistryTest . java <nl> ppp RegistryTest . java <nl> + @Test <nl> + public void testFips_succeedsOnSuccessiveRestrictToFips() throws Exception { <nl> + Registry . reset() ; <nl> + Registry . restrictToFipsIfEmpty() ; <nl> + Registry . restrictToFipsIfEmpty() ; <nl> + Registry . restrictToFipsIfEmpty() ; <nl> + assertTrue(TinkFipsUtil . useOnlyFips()) ; <nl> + } <nl> + @Test <nl> + public void testFips_succeedsOnRestrictToFipsWhenBuiltInFipsMode() throws Exception { <nl> + Assume . assumeTrue(TinkFipsUtil . useOnlyFips()) ; <nl> + Registry <nl>,"do not fail when set fips mode in java , if it have be set successfully previously",1
0150d869accc7680e2bffa51e80af37ff3b469ff,2022-10-18 07:22:47-07:00,"mmm JsonKeysetReader . java <nl> ppp JsonKeysetReader . java <nl> - public static KeysetReader withInputStream(InputStream input) throws IOException { <nl> + @SuppressWarnings(""CheckedExceptionNotThrown"") <nl> + public static JsonKeysetReader withInputStream(InputStream input) throws IOException { <nl> + @InlineMe( <nl> + replacement = ""JsonKeysetReader . withInputStream(new FileInputStream(file))"", <nl> + imports = {""com . google . crypto . tink . JsonKeysetReader"", ""java . io . FileInputStream""}) <nl> + @Deprecated <nl> - return new JsonKeysetReader(new FileInputStream(file)) ; <nl> + return withInputStream(new FileInputStream(file)) ; <nl> + @InlineMe( <nl> + replacement = ""JsonKeysetReader . withInputStream(new FileInputStream(new File(path)))"", <nl> + imports = { <nl> + ""com . google <nl>",deprecate jsonkeysetreader.withfile and jsonkeysetreader.withpath,0
19526bacd3111e62feb801867e71a9f6e859aec8,2022-10-19 05:11:44-07:00,"mmm BinaryKeysetReader . java <nl> ppp BinaryKeysetReader . java <nl> + import com . google . errorprone . annotations . InlineMe ; <nl> + @InlineMe( <nl> + replacement = ""BinaryKeysetReader . withInputStream(new FileInputStream(file))"", <nl> + imports = {""com . google . crypto . tink . BinaryKeysetReader"", ""java . io . FileInputStream""}) <nl> + @Deprecated <nl> - return new BinaryKeysetReader(new FileInputStream(file)) ; <nl> + return withInputStream(new FileInputStream(file)) ; <nl> mmm BinaryKeysetWriter . java <nl> ppp BinaryKeysetWriter . java <nl> + import com . google . errorprone . annotations . InlineMe ; <nl> + @InlineMe( <nl> + replacement = ""BinaryKeysetWriter . <nl>",deprecate method withfile and withpath in remain reader and writer,1
eae48691f035e71816159b8996d2616bff35a957,2022-10-20 06:37:28-07:00,mmm KeysetHandle . java <nl> ppp KeysetHandle . java <nl> + @Deprecated <nl> mmm KeysetHandleTest . java <nl> ppp KeysetHandleTest . java <nl> - import com . google . crypto . tink . signature . SignatureKeyTemplates ; <nl> - KeysetHandle privateHandle = KeysetHandle . generateNew(SignatureKeyTemplates . ECDSA_P256) ; <nl> + KeysetHandle privateHandle = KeysetHandle . generateNew(KeyTemplates . get("ECDSA_P256")) ; <nl> + @SuppressWarnings("deprecation")  // This is a test for the deprecated function <nl> - public void readNoSecret_shouldWork() throws Exception { <nl> - KeysetHandle privateHandle = KeysetHandle . generateNew(SignatureKeyTemplates . ECDSA_P256) ; <nl> + public void deprecated_readNoSecretWithBytesInput_sameAs_parseKeysetWithoutSecret() <nl> + throws <nl>,deprecate keysethandle.readnosecret overload with binary input,1
53ba1091c82266a1b1ab305b6f8eb8e19afeeb0c,2022-10-20 12:37:20-07:00,mmm KeysetHandle . java <nl> ppp KeysetHandle . java <nl> + @Deprecated <nl> + @Deprecated <nl> mmm KeysetHandleTest . java <nl> ppp KeysetHandleTest . java <nl> + @SuppressWarnings("deprecation")  // This is a test for the deprecated function <nl> - public void getKeys() throws Exception { <nl> - KeyTemplate keyTemplate = KeyTemplates . get("AES128_EAX") ; <nl> - KeysetManager keysetManager = KeysetManager . withEmptyKeyset() ; <nl> - final int numKeys = 3 ; <nl> - for (int i = 0 ; i < numKeys ; i++) { <nl> - keysetManager . add(keyTemplate) ; <nl> - } <nl> - KeysetHandle handle <nl>,deprecate keyhandle function in keysethandle,0
afc5d42f2f0ad7fd1a80a76c8bfc42cd10a7ba03,2022-10-27 05:51:41-07:00,"mmm PrimitiveSet . java <nl> ppp PrimitiveSet . java <nl> + import com . google . errorprone . annotations . InlineMe ; <nl> + @InlineMe( <nl> + replacement = ""this . getPrimitive(CryptoFormat . getOutputPrefix(key))"", <nl> + imports = {""com . google . crypto . tink . CryptoFormat""}) <nl> + @Deprecated <nl>",deprecate getprimitive that take a proto key a input,1
14fa00a2e99628d672d4d4a41cde8696c4d7063c,2022-10-31 01:28:00-07:00,mmm FakeCloudKms . java <nl> ppp FakeCloudKms . java <nl> - return new DecryptResponse() . encodePlaintext(plaintext) ; <nl> + if (plaintext . length == 0) { <nl> + return new DecryptResponse() . encodePlaintext(null) ; <nl> + } else { <nl> + return new DecryptResponse() . encodePlaintext(plaintext) ; <nl> + } <nl> mmm GcpKmsAead . java <nl> ppp GcpKmsAead . java <nl> - return response . decodeCiphertext() ; <nl> + return toNonNullableByteArray(response . decodeCiphertext()) ; <nl> - return response . decodePlaintext() ; <nl> + return toNonNullableByteArray(response . decodePlaintext()) ; <nl> + private static final byte[] EMPTY_BYTE_ARRAY = new byte[0] ; <nl>,make sure that gcpkmsaead.decrypt do not return null,1
a050366e37677a0d4b43dd7e733589ecfba9f258,2022-11-16 07:19:45-08:00,mmm AesCmacParameters . java <nl> ppp AesCmacParameters . java <nl> - if (keySizeBytes == null || tagSizeBytes == null) { <nl> - throw new GeneralSecurityException("Key size and/or tag size not set") ; <nl> + if (keySizeBytes == null) { <nl> + throw new GeneralSecurityException("key size not set") ; <nl> + } <nl> + if (tagSizeBytes == null) { <nl> + throw new GeneralSecurityException("tag size not set") ; <nl> + } <nl> + if (variant == null) { <nl> + throw new GeneralSecurityException("variant not set") ; <nl> mmm HmacParameters . java <nl> ppp HmacParameters . java <nl> + if (variant <nl>,make sure that variant be not null in hmac and aescmac parameter,1
c2f8f02b23f9f435bf58d339a5636f319167faf1,2022-11-21 00:12:13-08:00,mmm KeyAccess . java <nl> ppp KeyAccess . java <nl> + @Deprecated <nl> mmm KeyHandle . java <nl> ppp KeyHandle . java <nl> + @Deprecated <nl> mmm SecretKeyAccess . java <nl> ppp SecretKeyAccess . java <nl> + @Deprecated <nl> mmm TinkKey . java <nl> ppp TinkKey . java <nl> + @Deprecated <nl>,deprecate tinkkey class,0
0fe4a8a33d72768c6cbee0ec228fa67143f84512,2022-12-28 07:18:51-08:00,mmm HmacProtoSerialization . java <nl> ppp HmacProtoSerialization . java <nl> - "Wrong type URL in call to HmacParameters . parseParameters: " <nl> + "Wrong type URL in call to HmacProtoSerialization . parseParameters: " <nl> - "Wrong type URL in call to HmacParameters . parseParameters") ; <nl> + "Wrong type URL in call to HmacProtoSerialization . parseKey") ; <nl>,fix error message in hmacprotoserialization,1
0712922251822c71272cfa2f88ed9f342ddde000,2023-01-16 01:41:40-08:00,"mmm AndroidKeystoreAesGcm . java <nl> ppp AndroidKeystoreAesGcm . java <nl> + import javax . crypto . AEADBadTagException ; <nl> - public byte[] decrypt(final byte[] ciphertext, final byte[] aad) <nl> - throws GeneralSecurityException { <nl> + public byte[] decrypt(final byte[] ciphertext, final byte[] aad) throws GeneralSecurityException { <nl> + if (ciphertext . length < IV_SIZE_IN_BYTES TAG_SIZE_IN_BYTES) { <nl> + throw new GeneralSecurityException(""ciphertext too short"") ; <nl> + } <nl> + } catch (AEADBadTagException ex) { <nl> + throw ex ; <nl> - if (ciphertext . length < IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) { <nl> - throw new GeneralSecurityException(""ciphertext too short"") ; <nl> <nl>",do not retry if decryption fail because of an invalid ciphertext,1
a4e7319f7e579c49a14e866ed6f2bbf049f13614,2023-02-17 04:30:37-08:00,mmm AeadKeyTemplates . java <nl> ppp AeadKeyTemplates . java <nl> - @Deprecated <nl> mmm DeterministicAeadKeyTemplates . java <nl> ppp DeterministicAeadKeyTemplates . java <nl> - @Deprecated <nl> mmm HybridKeyTemplates . java <nl> ppp HybridKeyTemplates . java <nl> - @Deprecated <nl> mmm MacKeyTemplates . java <nl> ppp MacKeyTemplates . java <nl> - @Deprecated <nl> mmm PrfKeyTemplates . java <nl> ppp PrfKeyTemplates . java <nl> - @Deprecated <nl> mmm SignatureKeyTemplates . java <nl> ppp SignatureKeyTemplates . java <nl> - @Deprecated <nl> mmm StreamingAeadKeyTemplates . java <nl> ppp StreamingAeadKeyTemplates . java <nl> - @Deprecated <nl>,undeprecate the keytemplate class,0
ff107f6c1c1a0f5a0c85b25ea3d9e0779ece9186,2023-02-27 08:11:25-08:00,mmm KeyAccess . java <nl> ppp KeyAccess . java <nl> - @Deprecated <nl> mmm KeyHandle . java <nl> ppp KeyHandle . java <nl> - @Deprecated  <nl> - @Deprecated <nl> mmm SecretKeyAccess . java <nl> ppp SecretKeyAccess . java <nl> - @Deprecated <nl> mmm TinkKey . java <nl> ppp TinkKey . java <nl> - @Deprecated <nl>,undeprecate everything in tinkkey,0
83427042cdc253d710922285c533b0322574f1e1,2023-04-26 03:15:10-07:00,mmm Ed25519 . java <nl> ppp Ed25519 . java <nl> + public static void init() { <nl> + if (Ed25519Constants . D == null) { <nl> + throw new IllegalStateException("Could not initialize Ed25519 . ") ; <nl> + } <nl> + } <nl> mmm Ed25519Verify . java <nl> ppp Ed25519Verify . java <nl> + Ed25519 . init() ; <nl>,make sure ed25519constants be initialize when a verify primitive be create,1
b1522b8eff9dc6aae01b539caaab0a873e8c8aa2,2023-06-27 03:22:30-07:00,mmm KeyManager . java <nl> ppp KeyManager . java <nl> - P getPrimitive(MessageLite key) throws GeneralSecurityException ; <nl> + @Deprecated // Unused Interface Method .  Will be removed .  <nl> + default P getPrimitive(MessageLite key) throws GeneralSecurityException { <nl> + throw new UnsupportedOperationException() ; <nl> + } <nl> - MessageLite newKey(ByteString serializedKeyFormat) throws GeneralSecurityException ; <nl> + @Deprecated // Unused Interface Method .  Will be removed .  <nl> + default MessageLite newKey(ByteString serializedKeyFormat) throws GeneralSecurityException { <nl> + throw new UnsupportedOperationException() ; <nl> + } <nl> - MessageLite newKey(MessageLite keyFormat) throws GeneralSecurityException ; <nl> + <nl>,deprecate unused and unnecessary method in the keymanager interface,1
582fe72367df82de142adc27407cbea1526f3d1c,2023-06-28 09:48:58-07:00,mmm RsaSsaPssSignKeyManagerTest . java <nl> ppp RsaSsaPssSignKeyManagerTest . java <nl> + if (TestUtil . isTsan()) { <nl> + return ; // too slow for tsan .  <nl> + } <nl> + if (TestUtil . isTsan()) { <nl> + return ; // too slow for tsan <nl> + } <nl> + if (TestUtil . isTsan()) { <nl> + return ; // too slow for tsan <nl> + } <nl> + if (TestUtil . isTsan()) { <nl> + return ; // too slow for tsan <nl> + } <nl> + if (TestUtil . isTsan()) { <nl> + return ; // <nl>,do not parse rsa key when use tsan,1
7d10e734ad5ec019a40cb699928bb3f0da68b762,2023-06-30 02:57:33-07:00,mmm KeysetHandle . java <nl> ppp KeysetHandle . java <nl> + @Deprecated <nl> mmm KeysetManager . java <nl> ppp KeysetManager . java <nl> - public synchronized KeysetManager add(KeyHandle keyHandle) throws GeneralSecurityException { <nl> + @Deprecated <nl> + public synchronized KeysetManager add(KeyHandle keyHandle) <nl> + throws GeneralSecurityException { <nl> + @Deprecated <nl>,deprecate method return keyhandle object,1
a752bb193b653431d5c59665208b4a649f89cc4e,2016-12-19 13:59:49+03:00,mmm PdfDocument . java <nl> ppp PdfDocument . java <nl> + addProducer() ; <nl> + info . addProducer() ; <nl> mmm PdfWriter . java <nl> ppp PdfWriter . java <nl> - if (getInfo() . contains(PdfName . PRODUCER) && Version . getInstance() . getVersion() . contains("licensed")) { <nl> + if (!getInfo() . getAsString(PdfName . PRODUCER) . toUnicodeString() . equals(Version . getInstance() . getVersion()) && Version . getInstance() . getVersion() . contains("licensed")) { <nl>,fix possible error with null producer line,1
237c9a2528bdd97030e8e2337f4b3df8f7062356,2017-02-02 14:08:50-07:00,mmm PdfContentStreamProcessor . java <nl> ppp PdfContentStreamProcessor . java <nl> + import com . itextpdf . text . pdf . PdfReader ; <nl> - PdfObject xobject = xobjects . getDirectObject(xobjectName) ; <nl> + PdfObject xobject = PdfReader . getPdfObjectRelease(xobjects . get(xobjectName)) ; <nl>,fix memory leak when parse pdf file with lot of xobjects,1
a011b74c313f09d8ebe2c9d0bca00ca4b1f1c060,2017-06-09 10:21:26+02:00,mmm StructureMCID . java <nl> ppp StructureMCID . java <nl> - this . pageref = pg . getNumber() ; <nl> + this . pageref = pg == null ? -1 : pg . getNumber() ; <nl>,"ensure that pg entry can be optional , a the spec intend",1
da26a1f60ee34f3dd58292df75ebd1a4cb397fea,2023-08-22 07:22:24-07:00,mmm GcsEnvelopeAeadExample . java <nl> ppp GcsEnvelopeAeadExample . java <nl> - import com . google . crypto . tink . KeyTemplates ; <nl> - import com . google . crypto . tink . KeysetHandle ; <nl> + import com . google . crypto . tink . KmsClient ; <nl> - import com . google . crypto . tink . aead . KmsEnvelopeAeadKeyManager ; <nl> + import com . google . crypto . tink . aead . KmsEnvelopeAead ; <nl> + import com . google . crypto . tink . aead . PredefinedAeadParameters ; <nl> - import java . util <nl>,do not register km client in gc envelope aead example,1
03a495b12077e74b92c207b09dc79110fb0cbff6,2023-09-15 05:56:10-07:00,mmm KeysetHandle . java <nl> ppp KeysetHandle . java <nl> - public static final KeysetHandle generateNew(com . google . crypto . tink . proto . KeyTemplate keyTemplate) <nl> - throws GeneralSecurityException { <nl> + @Deprecated <nl> + public static final KeysetHandle generateNew( <nl> + com . google . crypto . tink . proto . KeyTemplate keyTemplate) throws GeneralSecurityException { <nl>,deprecate the generatenew overload take a proto keytemplate,1
ad6b260f90b423ddedd0271dab7377cf61fbcd09,2023-12-04 13:40:53-08:00,"mmm KmsClients . java <nl> ppp KmsClients . java <nl> + @Deprecated // We do not recommend using this API, but there are no plans to remove it .  <nl> + @Deprecated // We do not recommend using this API, but there are no plans to remove it .  <nl> + @Deprecated // We do not recommend using this API, but there are no plans to remove it .  <nl> mmm KmsAeadKeyManager . java <nl> ppp KmsAeadKeyManager . java <nl> + @Deprecated // We do not recommend using this API, but there are no plans to <nl>","deprecate kmsclients , and it add and get function",1
9c09b67530a5d68646e5e818ae6614c880cf4d0b,2014-04-06 16:10:13+02:00,mmm EMVPaymentRecord . java <nl> ppp EMVPaymentRecord . java <nl> + public void setAmount(final Float amount) { <nl> + this . amount = amount ; <nl> + } <nl> + public void setCyptogramData(final String cyptogramData) { <nl> + this . cyptogramData = cyptogramData ; <nl> + } <nl> + public void setTerminalCountry(final CountryCodeEnum terminalCountry) { <nl> + this . terminalCountry = terminalCountry ; <nl> + } <nl> + public void setCurrency(final CurrencyEnum currency) { <nl> + this . currency = currency ; <nl> + } <nl> + public void setTransactionDate(final Date transactionDate) { <nl> + this . transactionDate = <nl>,fix error with setter for mobile app,1
9fac30611dbb02a4bbc72d5bb83db4b0626c8fa6,2014-04-07 23:53:48+02:00,mmm CardUtils . java <nl> ppp CardUtils . java <nl> + } else { <nl> + ret = "0000 0000 0000 0000" ; <nl> - switch (pEnum) { <nl> - case AMERICAN_EXPRESS: <nl> - ret = R . drawable . amex ; <nl> - break ; <nl> - case MASTER_CARD1: <nl> - case MASTER_CARD2: <nl> - ret = R . drawable . mastercard ; <nl> - break ; <nl> - case VISA: <nl> - ret = R . drawable . visa ; <nl> - break ; <nl> - default: <nl> - break ; <nl> + if (pEnum != null) <nl>,fix npe error,1
d5f6e6ad494d4d26593266fcb9bca168bbff51f8,2014-04-19 16:26:40+02:00,"mmm HomeActivity . java <nl> ppp HomeActivity . java <nl> + mException = false ; <nl> - display(getResources() . getText(R . string . error_communication_nfc), false) ; <nl> + } else { <nl> + display(getResources() . getText(R . string . error_communication_nfc), false) ; <nl>",fix error during read card,1
4bc7c66efdb6ce40d5888b74364057a77046a3d3,2014-05-07 23:30:19+02:00,mmm DefaultEmvParser . java <nl> ppp DefaultEmvParser . java <nl> + import com . github . devnied . emvnfccard . model . enums . CurrencyEnum ; <nl> - listRecord . add(record) ; <nl> + if (record != null) { <nl> + if (record . getCurrency() == null) { <nl> + record . setCurrency(CurrencyEnum . XXX) ; <nl> + } <nl> + listRecord . add(record) ; <nl> + } <nl> mmm HomeActivity . java <nl> ppp HomeActivity . java <nl> - if (mCard != null && StringUtils . isNotBlank(mCard . getAid())) { <nl> + if (mCard != null && StringUtils <nl>,fix error with unknown currency,1
d32ebdf09d75d68fa38261305fb858ebbda70d9e,2014-05-22 23:24:51+02:00,"mmm HomeActivity . java <nl> ppp HomeActivity . java <nl> + final Tag mTag = intent . getParcelableExtra(NfcAdapter . EXTRA_TAG) ; <nl> + if (mTag != null) { <nl> - new SimpleAsyncTask() { <nl> - private Tag mTag ; <nl> - private IsoDep mTagcomm ; <nl> - private EMVCard mCard ; <nl> - private boolean mException ; <nl> - @Override <nl> - protected void onPreExecute() { <nl> - super . onPreExecute() ; <nl> - if (mDialog == null) { <nl> - mDialog = ProgressDialog . show(HomeActivity . this, getString(R . string . card_reading), <nl> - getString(R . string . <nl>",fix error with intent,1
b3030ac15b52ef698670de7b06fd619fd85c34b2,2014-07-09 21:16:17+02:00,"mmm TagValueFactory . java <nl> ppp TagValueFactory . java <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> + -			val = BytesUtils . toByteArray(CountryCodeEnum . FR . getNumeric()) ; <nl> + val = BytesUtils . fromString(StringUtils . leftPad(String . valueOf(CountryCodeEnum . FR . getNumeric()), 4, ""0"")) ; <nl> - val = BytesUtils . toByteArray(CurrencyEnum . EUR . getISOCodeNumeric()) ; <nl> + val = BytesUtils . fromString(StringUtils . leftPad(String . valueOf(CurrencyEnum . EUR . getISOCodeNumeric()), 4, ""0"")) ; <nl> - val = BytesUtils . fromString(""99"") ; <nl> + val = BytesUtils . fromString(""00"") ; <nl>",fix error in gpo command,1
370598bff914eb41bce175c9848d4495784c1bbe,2014-08-12 20:05:26+03:00,"mmm CardDetailFragment . java <nl> ppp CardDetailFragment . java <nl> - if (mCard != null) { <nl> - mEmptyView . setVisibility(View . GONE) ; <nl> - mScrollView . setVisibility(View . VISIBLE) ; <nl> - mCardNumber . setText(CardUtils . formatCardNumber(mCard . getCardNumber(), mCard . getType())) ; <nl> - SimpleDateFormat format = new SimpleDateFormat(""MM/yy"", Locale . getDefault()) ; <nl> - mCardValidity . setText(format . format(mCard . getExpireDate())) ; <nl> - mImageView . setImageResource(CardUtils . getResourceIdCardType(mCard . getType())) ; <nl> - mExtendedLayout . removeAllViews() ; <nl> - if (mCard . getHolderName() != null && mCard . getHolderName() . length() > 1) { <nl>",fix update when activity in not attach to fragment,1
0d3b42657f0ce6dff52b4e60530cfff761f09510,2014-08-31 18:35:30+02:00,mmm HomeActivity . java <nl> ppp HomeActivity . java <nl> + import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> + import java . util . Date ; <nl> + import java . util . List ; <nl> + import com . github . devnied . emvnfccard . BuildConfig ; <nl> + import com . github . devnied . emvnfccard . enums . EmvCardScheme ; <nl> + import com . github . devnied . emvnfccard . model . EmvTransactionRecord ; <nl> + import com . github . devnied . emvnfccard . <nl>,fix application error,0
cd66ddf26984bac9af7d3b0584f24d9c316efd37,2013-10-16 23:02:38+09:00,mmm HikariPool . java <nl> ppp HikariPool . java <nl> - int maxIters = configuration . getMinimumPoolSize() / configuration . getAcquireIncrement() ; <nl> + int maxIters = (configuration . getMinimumPoolSize() / configuration . getAcquireIncrement()) 1 ; <nl> mmm CreationTest . java <nl> ppp CreationTest . java <nl> + config . setAcquireIncrement(1) ; <nl> + config . setAcquireIncrement(1) ; <nl> mmm MockDataSource . java <nl> ppp MockDataSource . java <nl> + when(mockConnection . isValid(anyInt())) . thenReturn(true) ; <nl>,fix pool fill error when acquire increment be great than min pool size,1
e021074764747d7d8edee10163feeceea3604818,2014-01-09 17:06:20+09:00,mmm ConnectionProxy . java <nl> ppp ConnectionProxy . java <nl> - openStatements . get(i) . close() ; <nl> + try <nl> + { <nl> + openStatements . get(i) . close() ; <nl> + } <nl> + catch (SQLException e) <nl> + { <nl> + checkException(e) ; <nl> + } <nl>,ensure that even if a close statement fails during connection close that we continue to try to close additional statement,1
430c6a4d56cbc2b1ed4c1a7246698b20f610e8ea,2014-04-08 22:20:12+09:00,mmm HikariPool . java <nl> ppp HikariPool . java <nl> - statement . setQueryTimeout((int) TimeUnit . MILLISECONDS . toSeconds(timeoutMs)) ; <nl> + if (timeoutMs < Integer . MAX_VALUE) <nl> + { <nl> + statement . setQueryTimeout((int) TimeUnit . MILLISECONDS . toSeconds(timeoutMs)) ; <nl> + } <nl>,do not set query timeout when user specifies connectiontimeout of 0,1
d1138e6e5f75f9358be6d00a96dbb94b840c5c81,2014-06-27 09:13:04+03:00,mmm HikariDataSource . java <nl> ppp HikariDataSource . java <nl> - else if (!username . equals(otherKey . username)) { <nl> + else if (username != otherKey . username) { <nl> - else if (!password . equals(otherKey . password)) { <nl> + else if (password != otherKey . password) { <nl>,fix not to throw npe if username or password be null,1
98cbc3b36d58f4a7002f41c80fec8290a6eaff1f,2014-10-11 15:52:42+09:00,mmm ConnectionProxy . java <nl> ppp ConnectionProxy . java <nl> - if (!delegate . getAutoCommit()) { <nl> - delegate . rollback() ; <nl> - } <nl> + if (!delegate . getAutoCommit()) { <nl> + delegate . rollback() ; <nl> + } <nl> mmm ConnectionProxy . java <nl> ppp ConnectionProxy . java <nl> - if (!delegate . getAutoCommit()) { <nl> - delegate . rollback() ; <nl> - } <nl> + if (!delegate . getAutoCommit()) { <nl> + delegate . rollback() ; <nl> + } <nl>,do not skip rollback just because nothing be dirty,1
8f24815a4a794c1d01bc65696ddc4628a82be322,2014-10-13 21:47:23+09:00,mmm MiscTest . java <nl> ppp MiscTest . java <nl> - PoolUtilities . quietlySleep(TimeUnit . SECONDS . toMillis(4)) ; <nl> + PoolUtilities . quietlySleep(TimeUnit . SECONDS . toMillis(5)) ; <nl> mmm MiscTest . java <nl> ppp MiscTest . java <nl> - PoolUtilities . quietlySleep(TimeUnit . SECONDS . toMillis(4)) ; <nl> + PoolUtilities . quietlySleep(TimeUnit . SECONDS . toMillis(5)) ; <nl>,"try to fix travis-ci failure , work locally not occasionally fail , seem to be time sensitive",1
6772e5f4ca59cae6908df34d2cf5dfe534053e3e,2014-12-02 12:20:56+09:00,mmm ConcurrentBag . java <nl> ppp ConcurrentBag . java <nl> - import sun . reflect . generics . reflectiveObjects . NotImplementedException ; <nl> - throw new NotImplementedException() ; <nl> + throw new RuntimeException("createQueuedSynchronizer() method must be overridden") ; <nl>,"do not throw sun internal notimplementedexception , just throw a runtimeexception",1
40e44c5688ab89aadd54c79d0ac831ae60e3129f,2014-10-22 23:24:43+08:00,"mmm BTCChinaSocketIOClientBuilder . java <nl> ppp BTCChinaSocketIOClientBuilder . java <nl> - final List<String> params = new ArrayList<String>(4) ; <nl> + final List<String> params = buildPrivateDataParams() ; <nl> + if (!params . isEmpty()) { <nl> + BTCChinaPayload payload = getPayload(params . toArray(new String[0])) ; <nl> + final List<String> arg = new ArrayList<String>(2) ; <nl> + arg . add(toPostData(payload)) ; <nl> + arg . add(getSign(payload)) ; <nl> + socket . emit(""private"", arg) ; <nl> + } else { <nl> + log . debug(""No private data specified to subscribe . "") ; <nl> + } <nl> + } <nl> + private List<String> <nl>","fix npe in btcchinasocketioclientbuilder : if no private data specify to subscribe , do not emit private event",1
9b30c24674f5d3db4a3aee6db141a66e06c53027,2015-02-03 01:36:01+01:00,mmm BaseExchange . java <nl> ppp BaseExchange . java <nl> - if (exchangeSpecification . getExchangeName() != null) { <nl> + if (this . exchangeSpecification . getExchangeName() != null) { <nl> - MetaData metaData = null ; <nl> - this . metaData = metaData ; <nl>,fix potential npe,1
d538f9864c841c36b7f47a3db6d8891e454a4789,2015-04-07 14:40:21+09:00,mmm HikariConfig . java <nl> ppp HikariConfig . java <nl> + if (poolName == null) { <nl> + poolName = "HikariPool-" poolNumber++ ; <nl> + } <nl> - if (poolName == null) { <nl> - poolName = "HikariPool-" + poolNumber++ ; <nl> - } <nl>,fix build break cause by npe.. dereferencing member before it be initialize,1
8da7ced9a89a4e190162d7e2925c3caf791e7ec7,2015-04-15 22:52:26+10:00,"mmm HikariPool . java <nl> ppp HikariPool . java <nl> - final long start = System . nanoTime() ; <nl> - do { <nl> - softEvictConnections() ; <nl> - abortActiveConnections(assassinExecutor) ; <nl> + try { <nl> + final long start = System . nanoTime() ; <nl> + do { <nl> + softEvictConnections() ; <nl> + abortActiveConnections(assassinExecutor) ; <nl> + } <nl> + while (getTotalConnections() > 0 && elapsedTimeNano(start) < TimeUnit . SECONDS . toNanos(5)) ; <nl> + } finally { <nl> + assassinExecutor . shutdown() ; <nl> + assassinExecutor . awaitTermination(5L, TimeUnit . SECONDS) ; <nl> - while (getTotalConnections() <nl>",make sure temporary pool be shut down,1
f6e9793034de90bd373e1065728604255b627fb2,2015-07-22 21:26:20+05:30,mmm PoolElf . java <nl> ppp PoolElf . java <nl> - package com . zaxxer . hikari . pool ;,try not sure why the whole file show in diff before,1
e19c6874431dc2c3046436c2ac249a0ab2ef3457,2015-07-31 12:03:20-04:00,mmm ConnectionProxy . java <nl> ppp ConnectionProxy . java <nl> - final int size = openStatements . size() ; <nl> - if (size > 0) { <nl> - for (int i = 0 ; i < size ; i++) { <nl> - try { <nl> - openStatements . get(i) . close() ; <nl> - } <nl> - catch (SQLException e) { <nl> - checkException(e) ; <nl> - } <nl> - } <nl> - } <nl> + closeOpenStatements() ; <nl> + private void closeOpenStatements() <nl> + { <nl> + final int size = openStatements . size() ; <nl> + if <nl>,ensure close connection return to pool,1
af4f8a991ca0ba6de9fd4be89a7ad4d53ebeece8,2015-08-27 16:15:27+05:30,mmm PoolElf . java <nl> ppp PoolElf . java <nl> - final int defaultLevel = connection . getTransactionIsolation() ; <nl> - transactionIsolation = (transactionIsolation < 0 ? defaultLevel : transactionIsolation) ; <nl> - if (transactionIsolation != defaultLevel) { <nl> + if (transactionIsolation == -1) { <nl> + transactionIsolation = connection . getTransactionIsolation() ; <nl> + } <nl> + else if (transactionIsolation != Connection . TRANSACTION_NONE) { <nl>,do not set connection with property that user have not specify,1
480fd309d206af0103f3a034f5edeb49c9fa5fd4,2015-08-27 19:08:01+05:30,mmm PoolElf . java <nl> ppp PoolElf . java <nl> - else if (transactionIsolation != Connection . TRANSACTION_NONE) { <nl> - connection . setTransactionIsolation(transactionIsolation) ; <nl> + else { <nl> + int defaultTILevel = connection . getTransactionIsolation() ; <nl> + if (transactionIsolation != defaultTILevel) { <nl> + transactionIsolation = defaultTILevel ; <nl> + } <nl> + if (transactionIsolation != Connection . TRANSACTION_NONE) { <nl> + connection . setTransactionIsolation(transactionIsolation) ; <nl> + } <nl>,do not call set if default be same a user specify,1
dd6fdae57ed1d68308a8cf35d50feadf37657d7f,2015-08-27 19:41:32+05:30,mmm PoolElf . java <nl> ppp PoolElf . java <nl> - if (transactionIsolation == -1) { <nl> - transactionIsolation = connection . getTransactionIsolation() ; <nl> - } <nl> - else { <nl> - int defaultTILevel = connection . getTransactionIsolation() ; <nl> - if (transactionIsolation != defaultTILevel) { <nl> - transactionIsolation = defaultTILevel ; <nl> - } <nl> - if (transactionIsolation != Connection . TRANSACTION_NONE) { <nl> - connection . setTransactionIsolation(transactionIsolation) ; <nl> - } <nl> + final int defaultLevel = connection . getTransactionIsolation() ; <nl> + transactionIsolation = (transactionIsolation < 0 || defaultLevel == Connection . TRANSACTION_NONE) <nl> + <nl>,do not call set for transaction_none,0
12dbecd8593536b9aa4cff2f2634a7ebd2009545,2015-10-14 15:53:56+05:30,"mmm ProxyConnection . java <nl> ppp ProxyConnection . java <nl> - @Override <nl> - public Object invoke(Object proxy, Method method, Object[] args) throws Throwable <nl> - { <nl> - final String methodName = method . getName() ; <nl> - if (""isValid"" . equals(methodName)) { <nl> - return Boolean . FALSE ; <nl> - } <nl> - else if (""close"" . equals(methodName)) {  <nl> - return Void . TYPE ; <nl> - } <nl> - else if (""abort"" . equals(methodName)) {  <nl> - return Void . TYPE ; <nl> - } <nl> - else if (""toString"" . equals(methodName)) <nl>",close should throw exception,1
4847a653f2be9b2cd773592d7cd8c8bdf2ce1d2d,2015-11-13 14:20:09+05:30,"mmm HikariPool . java <nl> ppp HikariPool . java <nl> - connectionBag . close() ; <nl> - softEvictConnections() ; <nl> + connectionBag . close() ; <nl> - while (totalConnections . get() < config . getMaximumPoolSize()) { <nl> + while (poolState == POOL_NORMAL && totalConnections . get() < config . getMaximumPoolSize()) { <nl> mmm ShutdownTest . java <nl> ppp ShutdownTest . java <nl> - Assert . assertTrue(""Totals connection count not as expected, "", pool . getTotalConnections() > 0) ; <nl> + Assert . assertTrue(""Total connection count not as expected, "", pool . getTotalConnections() > 0) ; <nl> - Assert . <nl>","do not add con if pool be not normal , avoid exception in shutdown",1
1e24d50f977fbfd753b4ec214d8b179632f7dc16,2015-12-03 16:28:25+05:30,mmm TestConnections . java <nl> ppp TestConnections . java <nl> - StubConnection . count . set(0) ; // reset connection counter <nl> + ds . getConnection() . close() ;  // initialize <nl> + StubConnection . count . set(0) ; // now reset counter <nl>,make sure pool be ready before reset counter,1
0e3f0eb0f6a808a7e07e88c9bd60d90584f89d7b,2016-01-29 12:06:50+05:30,"mmm HikariConfig . java <nl> ppp HikariConfig . java <nl> - if (leakDetectionThreshold != 0 && leakDetectionThreshold < TimeUnit . SECONDS . toMillis(2) && !unitTest) { <nl> - LOGGER . warn(""leakDetectionThreshold is less than 2000ms, setting to minimum 2000ms . "") ; <nl> - leakDetectionThreshold = 2000L ; <nl> - } <nl> + if (leakDetectionThreshold != 0 && leakDetectionThreshold < TimeUnit . SECONDS . toMillis(2) && !unitTest) { <nl> + LOGGER . warn(""leakDetectionThreshold is less than 2000ms, setting to minimum 2000ms . "") ; <nl> + leakDetectionThreshold = 2000L ; <nl> + } <nl> + else if (leakDetectionThreshold > <nl>",leakdetectionthreshold should be less than maxlifetime,1
91ad77b142c75e4512ac7d7c84c765d110651de5,2016-01-30 22:22:07+09:00,"mmm HikariPool . java <nl> ppp HikariPool . java <nl> - if (now + 128 < clockSource . plusMillis(previous, HOUSEKEEPING_PERIOD_MS)) { <nl> + if (clockSource . plusMillis(now, 128) < clockSource . plusMillis(previous, HOUSEKEEPING_PERIOD_MS)) { <nl>",do not assume 'now ' be in millisecond.. it 's probably nanosecond on most platform,1
d3bc0a155aa069f756a4a655f7c080f67b7506b9,2016-02-02 11:52:13+05:30,"mmm HikariPool . java <nl> ppp HikariPool . java <nl> - this . closeConnectionExecutor = createThreadPoolExecutor(1 + (config . getMaximumPoolSize() / 2), poolName + "" connection closer"", threadFactory, new ThreadPoolExecutor . CallerRunsPolicy()) ; <nl> + this . closeConnectionExecutor = createThreadPoolExecutor(config . getMaximumPoolSize(), poolName "" connection closer"", threadFactory, new ThreadPoolExecutor . CallerRunsPolicy()) ; <nl>",it be 1 thread so have queue size that mostly do not require to queue,1
a3386d080e593d3f942da6f067e126b2a01fc54c,2017-01-08 19:08:58+09:00,mmm ConcurrentBag . java <nl> ppp ConcurrentBag . java <nl> + if (waiters . get() != 0) { <nl> + synchronizer . signal() ; <nl> + } <nl> - synchronizer . signal() ; <nl>,"performance tweak , only signal if there be thread wait",1
d875e838c386de18bbf41fb5b8017fbc98f6ceb3,2017-02-16 15:00:58-05:00,mmm HikariPool . java <nl> ppp HikariPool . java <nl> + metricsTracker . recordBorrowTimeoutStats(startTime) ; <nl> mmm PoolBase . java <nl> ppp PoolBase . java <nl> + default void recordBorrowTimeoutStats(long startTime) {} <nl> + @Override <nl> + public void recordBorrowTimeoutStats(long startTime) <nl> + { <nl> + tracker . recordConnectionAcquiredNanos(elapsedNanos(startTime)) ; <nl> + } <nl> new file <nl> ppp MetricsTrackerTest . java <nl> + package com . zaxxer . hikari . pool ; <nl> + import com . zaxxer . hikari . HikariDataSource ; <nl> + import com . zaxxer . hikari . metrics . IMetricsTracker ; <nl> + import <nl>,pool.wait metric do not include time out request,1
63f6ff371fef264142bd70b4c568209a58c9b9cd,2017-09-22 21:03:14+09:00,mmm HikariPool . java <nl> ppp HikariPool . java <nl> - if (metricRegistry instanceof MetricRegistry) { <nl> + if (metricRegistry . getClass() . getName() . contains("MetricRegistry")) { <nl> - else if (metricRegistry instanceof MeterRegistry) { <nl> + else if (metricRegistry . getClass() . getName() . contains("MeterRegistry")) { <nl>,fix classnotfoundexception when com.codahale.metrics.metricregistry be not in the classpath,1
a7f9a4b2f52bb73c3419abee7da974bbc6f264d8,2022-12-01 22:50:29+09:00,"mmm PoolBase . java <nl> ppp PoolBase . java <nl> + setNetworkTimeout(connection, validationTimeout) ; <nl> - setNetworkTimeout(connection, validationTimeout) ; <nl> mmm StubConnection . java <nl> ppp StubConnection . java <nl> + public static volatile Callable<Void> networkTimeoutSetter ; <nl> + if (networkTimeoutSetter != null) { <nl> + try { <nl> + networkTimeoutSetter . call() ; <nl> + } <nl> + catch (SQLException e) { <nl> + throw e ; <nl> + } <nl> + catch (Exception e) { <nl> + throw new RuntimeException(e) ; <nl> + } <nl> + } <nl> mmm ExceptionTest . java <nl> ppp ExceptionTest . java <nl>",do not attempt second setnetworktimeout call if first fails,1
2021f90444604cc67989054b50643502c1006914,2023-09-16 01:16:56+09:00,mmm CodahaleHealthChecker . java <nl> ppp CodahaleHealthChecker . java <nl> - import java . sql . Connection ; <nl> - import java . sql . SQLException ; <nl> - import java . util . concurrent . TimeUnit ; <nl> + import java . sql . Connection ; <nl> + import java . sql . SQLException ; <nl> + import java . util . concurrent . TimeUnit ; <nl> - final var metricRegistry = (MetricRegistry) hikariConfig . getMetricRegistry() ; <nl> - if (metricRegistry != null && expected99thPercentile > 0) { <nl> + final Object metricRegistryObj = hikariConfig . getMetricRegistry() ; <nl>,do not try to cast metric registry before it be check for null,1
a60abfbde515e860c9027e5f519b0ead15130d52,2014-06-26 18:30:11-04:00,"mmm TemporaryPorts . java <nl> ppp TemporaryPorts . java <nl> + if (!lock . isValid()) { <nl> + log . debug(""lock already released: {}"", path) ; <nl> + return ; <nl> + } <nl> - log . error(""caught exception releasing port lock: {}"", path, e) ; <nl> + log . warn(""caught exception releasing port lock: {}"", path, e) ; <nl> - log . error(""caught exception closing port lock file: {}"", path, e) ; <nl> + log . warn(""caught exception closing port lock file: {}"", path, e) ; <nl> - log . error(""caught exception deleting port lock file: {}"", path, <nl>",temporary port : do not release file lock twice,1
2aa9b44c572f490e980965f30e8745f14d905820,2014-07-16 18:09:38-04:00,"mmm TemporaryJobs . java <nl> ppp TemporaryJobs . java <nl> - if (file . getName() . endsWith("" . tmp"")) { <nl> - continue ; <nl> + if (file . getName() . endsWith("" . tmp"") || file . isDirectory()) { <nl> + continue ; <nl> mmm TemporaryJobsTest . java <nl> ppp TemporaryJobsTest . java <nl> - prefixDirectory = tempFolder() ; <nl> + prefixDirectory = temporaryFolder . newFolder() . toPath() ; <nl> - JobPrefixFile file1 = JobPrefixFile . create(jobId1 . getName(), tempFolder()) ; <nl> - JobPrefixFile file2 = JobPrefixFile . create(jobId2 . getName(), tempFolder()) ; <nl> - JobPrefixFile file3 = JobPrefixFile <nl>",temporaryjobs no longer throw an exception if it encounter a directory,1
605e04a2c7640aaf304c8cda53396bfbea827fb8,2014-07-28 13:12:26-04:00,mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> + if (jobs == null) { <nl> + if (client . exists(Paths . configHost(host)) == null) { <nl> + throw new HostNotFoundException("host [" host "] does not exist") ; <nl> + } <nl> + } <nl> mmm DeregisterTest . java <nl> ppp DeregisterTest . java <nl> + @Test <nl> + public void testDeregisterHostThatDoesntExist() throws Exception { <nl> + startDefaultMaster() ; <nl> + final String host = testHost() ; <nl> + final HeliosClient client = defaultClient() ; <nl> + final HostDeregisterResponse deregisterResponse = client . deregisterHost(host) . get() ; <nl> <nl>,fix npe when deregistering a host that do not exist,1
53f87583ea3b17de513973253943c999712e14c1,2014-08-06 21:57:23-04:00,"mmm HeliosClient . java <nl> ppp HeliosClient . java <nl> - ImmutableSet . of(HTTP_OK, HTTP_BAD_REQUEST))) ; <nl> + ImmutableSet . of(HTTP_OK, HTTP_NOT_FOUND, <nl> + HTTP_BAD_REQUEST))) ; <nl> - ImmutableSet . of(HTTP_OK, HTTP_NOT_FOUND))) ; <nl> + ImmutableSet . of(HTTP_OK, HTTP_NOT_FOUND, <nl> + HTTP_BAD_REQUEST))) ; <nl> mmm JobDeleteResponse . java <nl> ppp JobDeleteResponse . java <nl> - public enum Status { OK, STILL_IN_USE } <nl> + public enum Status { OK, STILL_IN_USE, JOB_NOT_FOUND } <nl> mmm JobsResource . java <nl> ppp JobsResource . java <nl> - throw notFound() ; <nl> + throw notFound(new JobDeleteResponse(JobDeleteResponse . Status . JOB_NOT_FOUND)) ; <nl> mmm <nl>","heliosclient should return jobdeleteresponse , not null , when delete nonexistent job",1
6df7fff8f4893925cb66ceee191a78e04e280511,2014-09-09 15:44:58-04:00,mmm TemporaryJob . java <nl> ppp TemporaryJob . java <nl> - if (state == TaskStatus . State . UNKNOWN || <nl> - state == TaskStatus . State . FAILED || <nl> + if (state == TaskStatus . State . FAILED || <nl>,do not fail when job in unknown state,1
ab133a06749986d1e5707ca6913aaea9ccda8e13,2014-09-24 15:30:30-04:00,"mmm TaskRunner . java <nl> ppp TaskRunner . java <nl> + import com . spotify . docker . client . DockerTimeoutException ; <nl> + import com . spotify . docker . client . ImageNotFoundException ; <nl> + import com . spotify . docker . client . ImagePullFailedException ; <nl> + DockerTimeoutException wasTimeout = null ; <nl> + } catch (DockerTimeoutException e) { <nl> + log . warn(""Pulling image {} failed with timeout"", image, e) ; <nl> + wasTimeout = e ; <nl> - docker . inspectImage(image) ; <nl> + try { <nl> + docker . inspectImage(image) ; <nl> + <nl>",correctly report error vs. not found,1
8213286085d0f877373e0e433fa6e35c870c27ed,2014-09-29 13:50:57-04:00,mmm AgentMain . java <nl> ppp AgentMain . java <nl> + import sun . misc . Signal ; <nl> + import sun . misc . SignalHandler ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> + import java . util . concurrent . atomic . AtomicReference ; <nl> + final AgentMain main ; <nl> + final AtomicBoolean exitSignalTriggered = new AtomicBoolean(false) ; <nl> + final AtomicReference<SignalHandler> existingIntHandler = <nl> + new AtomicReference<SignalHandler>(null) ; <nl> + final SignalHandler handler = new SignalHandler() { <nl> + @Override <nl> + public void handle(Signal signal) { <nl> <nl>,make sure agentserver actually execute shutdown,1
c311ec46bd0e09aed4b15f537d6351a4f2e62258,2014-10-22 14:03:23-04:00,mmm DefaultDeployer . java <nl> ppp DefaultDeployer . java <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . base . Throwables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . spotify . helios . common . descriptors . HostStatus . Status ; <nl> - final String chosenHost = hostPicker . pickHost(filteredHosts) ; <nl> + final String chosenHost = pickHost(filteredHosts) ; <nl> + @VisibleForTesting <nl> + String pickHost(final List<String> filteredHosts) { <nl> + final List<String> mutatedList = <nl>,do not deploy to host that be down,1
f8885cdf9feae4c732a1e1f8da017d8ca7486c38,2014-10-27 14:27:22-04:00,"mmm TaskConfig . java <nl> ppp TaskConfig . java <nl> - builder . hostname(containerHostname(job . getId() . getName() + ""_"" + <nl> - job . getId() . getVersion())) ; <nl> mmm ContainerHostNameTest . java <nl> ppp ContainerHostNameTest . java <nl> - final String needle = testJobName + ""_"" + testJobVersion + "" . "" + testHost() ; <nl> - assertThat(log, containsString(needle)) ; <nl> + assertThat(log, containsString(testHost())) ; <nl>",do not set container hostname,1
e7306d4ba1d2d4787cca752022f3037f7e917dee,2014-11-04 13:24:53-05:00,"mmm JobStatusCommand . java <nl> ppp JobStatusCommand . java <nl> - out . printf(""host pattern %s matched no jobs%n"", hostPattern) ; <nl> + out . printf(""host pattern %s matched no hosts%n"", hostPattern) ; <nl>",fix error message in cli,0
5e3f1a93e36bc2fa0c237a1641885af41ef4f7f2,2014-11-13 15:19:22-05:00,mmm TaskConfig . java <nl> ppp TaskConfig . java <nl> - builder . domainname(host) ; <nl> deleted file <nl> mmm ContainerHostNameTest . java <nl> - package com . spotify . helios . system ; <nl> - import com . google . common . base . Splitter ; <nl> - import com . spotify . docker . client . DockerClient ; <nl> - import com . spotify . docker . client . LogStream ; <nl> - import com . spotify . helios . common . descriptors . JobId ; <nl> - import com . spotify . helios . common . <nl>,do not set container hostname or domain,1
e4deb8d5d96c365fba4d2d5cdd1b86c1d391c015,2014-11-18 17:43:35-05:00,mmm SyslogRedirectingContainerDecorator . java <nl> ppp SyslogRedirectingContainerDecorator . java <nl> - final String syslogRedirectorPath = Optional . of(job . getEnv() . get("SYSLOG_REDIRECTOR")) <nl> + final String syslogRedirectorPath = Optional . fromNullable(job . getEnv() . get("SYSLOG_REDIRECTOR")) <nl>,fix npe throw by optional,1
c5f8dd5f62a1f09760e8e1440366332eb0c3a20e,2014-12-18 19:31:21-05:00,"mmm JobDeployResponse . java <nl> ppp JobDeployResponse . java <nl> - AMBIGUOUS_JOB_REFERENCE <nl> + AMBIGUOUS_JOB_REFERENCE, <nl> + UNAUTHORIZED <nl> mmm JobUndeployResponse . java <nl> ppp JobUndeployResponse . java <nl> - INVALID_ID <nl> + INVALID_ID, <nl> + UNAUTHORIZED <nl> mmm SetGoalResponse . java <nl> ppp SetGoalResponse . java <nl> - INVALID_ID <nl> + INVALID_ID, <nl> + UNAUTHORIZED <nl> mmm ExpiredJobReaper . java <nl> ppp ExpiredJobReaper . java <nl> - masterModel . undeployJob(host, jobId) ; <nl> + masterModel . undeployJob(host, jobId, null) ; <nl> + } catch (TokenVerificationException e) { <nl> + log . error(""couldn't undeploy job {} from host {} <nl>",fail request if token do not match,1
18c3aa28b66a9c56f28101e0a77f44c11b6ba1f1,2015-02-03 22:15:54+01:00,mmm HeliosClient . java <nl> ppp HeliosClient . java <nl> + import java . net . UnknownHostException ; <nl> - } catch (ConnectException e) { <nl> + } catch (ConnectException | UnknownHostException e) { <nl> + log . debug(e . getClass() . getSimpleName() " - " e . getMessage()) ; <nl>,heliosclient should retry if unknownhostexception be throw,1
2fded387cd706a8bd5217182c649bbf36fbb3411,2015-03-05 13:22:26-05:00,mmm TaskRunner . java <nl> ppp TaskRunner . java <nl> - import static java . util . concurrent . TimeUnit . MINUTES ; <nl> - private static final long HEALTHCHECK_MAX_RETRY_MILLIS = MINUTES . toMillis(5) ; <nl> - long totalMillis = 0 ; <nl> - totalMillis += retryMillis ; <nl> - if (totalMillis >= HEALTHCHECK_MAX_RETRY_MILLIS) { <nl> - docker . killContainer(containerId) ; <nl> - throw new RuntimeException("container failed repeated health checks") ; <nl> - } else { <nl> - Thread . sleep(retryMillis) ; <nl> - } <nl> + Thread . sleep(retryMillis) ; <nl>,do not kill container if health check fail,1
52c12ceef9d418f5f5069dad4cb7dc3e108ab49a,2015-04-29 15:50:23-04:00,mmm TaskRunner . java <nl> ppp TaskRunner . java <nl> - final String containerId = createAndStartContainer() ; <nl> - this . containerId = Optional . of(containerId) ; <nl> - if (healthChecker . isPresent()) { <nl> - listener . healthChecking() ; <nl> - final RetryScheduler retryScheduler = BoundedRandomExponentialBackoff . newBuilder() <nl> -  . setMinIntervalMillis(SECONDS . toMillis(1)) <nl> -  . setMaxIntervalMillis(SECONDS . toMillis(30)) <nl> -  . build() . newScheduler() ; <nl> - while (!healthChecker . get() . check(containerId)) { <nl> - final ContainerState state = docker . inspectContainer(containerId) . state() ; <nl> - if (!state . running()) { <nl>,do not health check already running container,1
71868d54fb2537dfcfad68afae1bd8203e6f6149,2015-07-13 18:18:24-04:00,"mmm RollingUpdateService . java <nl> ppp RollingUpdateService . java <nl> - hostsToLabels . put(host, hostStatus . getLabels()) ; <nl> + if (hostStatus != null) { <nl> + hostsToLabels . put(host, hostStatus . getLabels()) ; <nl> + } <nl>",fix npe in updatedeploymentgrouphosts,1
2c7218d08ff737eabeb9908643a11ce257fc6ab7,2015-07-13 18:37:52-04:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> - public List<String> getDeploymentGroupHosts(String name) <nl> + public List<String> getDeploymentGroupHosts(final String name) <nl> - return tryGetEntity(client, Paths . statusDeploymentGroupHosts(name), STRING_LIST_TYPE, ""hosts"") ; <nl> + try { <nl> + final byte[] data = client . getData(Paths . statusDeploymentGroupHosts(name)) ; <nl> + if (data . length > 0) { <nl> + return Json . read(data, STRING_LIST_TYPE) ; <nl> + } <nl> + } catch (NoNodeException e) { <nl> + } catch (KeeperException | IOException e) { <nl> + throw new HeliosRuntimeException(""reading deployment group hosts failed: "" name, e) ; <nl> + <nl>",do not die if deployment group have empty host node,1
b3513bc78d1b6370ea8fa15f5552115454c440fc,2015-07-28 14:35:48-04:00,"mmm KafkaClientProvider . java <nl> ppp KafkaClientProvider . java <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + private static final Logger log = LoggerFactory . getLogger(KafkaClientProvider . class) ; <nl> - return partialConfigs . transform( <nl> - new Function<ImmutableMap<String, Object>, KafkaProducer<K, V>>() { <nl> - @Nullable <nl> - @Override <nl> - public KafkaProducer<K, V> apply(ImmutableMap<String, Object> input) { <nl> - return new KafkaProducer<>(input, ks, vs) ; <nl> - } <nl> - }) ; <nl> + try { <nl> + return partialConfigs . transform( <nl> + new Function<ImmutableMap<String, <nl>",do not throw exception if kafka broker not find,1
423326386e31467904a203240b5a7568e96e4542,2015-07-30 10:23:52-04:00,"mmm ZooKeeperAgentModel . java <nl> ppp ZooKeeperAgentModel . java <nl> - historyWriter . saveHistoryItem(status) ; <nl> + try { <nl> + historyWriter . saveHistoryItem(status) ; <nl> + } catch (Exception e) { <nl> + log . error(""Error saving task status {} to ZooKeeper: {}"", status, e) ; <nl> + } <nl> mmm QueueingHistoryWriter . java <nl> ppp QueueingHistoryWriter . java <nl> + import java . util . Map ; <nl> - for (Object key : curKeys) { <nl> + for (final String key : curKeys) { <nl> - new ConcurrentLinkedDeque<TEvent>() ; <nl> + new ConcurrentLinkedDeque<>() ; <nl> - for <nl>",fail softly when agent can not save task history,1
6a3b2e0efca29c79e4576e3da1b162c21dabb1ea,2015-08-12 18:13:38-04:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> - final RollingUpdateOp op = <nl> - processRollingUpdateTask(client, opFactory, task, tasks . getDeploymentGroup()) ; <nl> + RollingUpdateOp op = processRollingUpdateTask( <nl> + client, opFactory, task, tasks . getDeploymentGroup()) ; <nl>",fix stylecheck error,0
48de14818a10bc8823d4075990bff3fec3ac1511,2015-09-03 13:33:37-04:00,"mmm DeploymentGroupStatusCommand . java <nl> ppp DeploymentGroupStatusCommand . java <nl> - out . printf(""Job Id: %s%n"", full ? jobId : jobId . toShortString()) ; <nl> + out . printf(""Job Id: %s%n"", full ? jobId : (jobId == null ? null : jobId . toShortString())) ; <nl> mmm DeploymentGroupStatusCommandTest . java <nl> ppp DeploymentGroupStatusCommandTest . java <nl> + @Test <nl> + public void testDeploymentGroupStatusBeforeRollingUpdate() throws Exception { <nl> + final DeploymentGroup deploymentGroupWithNoJob = new DeploymentGroup( <nl> + GROUP_NAME, HOST_SELECTORS, null, ROLLOUT_OPTIONS) ; <nl> + final List<DeploymentGroupStatusResponse . HostStatus> hostStatuses = Lists . newArrayList() ; <nl> + hostStatuses . add(new DeploymentGroupStatusResponse <nl>",fix npe in deployment-group-status command,1
631e8acba6a52dcd983a1fd8e524ee7207feaeff,2015-10-07 15:18:14-04:00,"mmm JobValidator . java <nl> ppp JobValidator . java <nl> + private final boolean shouldValidateJobHash ; <nl> + public JobValidator() { <nl> + this(true) ; <nl> + } <nl> + public JobValidator(final boolean shouldValidateJobHash) { <nl> + this . shouldValidateJobHash = shouldValidateJobHash ; <nl> + } <nl> - errors . addAll(validateJobHash(jobIdHash, recomputedId)) ; <nl> + if (this . shouldValidateJobHash) { <nl> + errors . addAll(validateJobHash(jobIdHash, recomputedId)) ; <nl> + } <nl> mmm Job . java <nl> ppp Job . java <nl> + public Job buildWithoutHash() { <nl> + final JobId id = new JobId(p . name, p . version) <nl>",do not calculate job hash on client-side,1
726dd542a2277adc200f41a55e0f8e9819683b34,2015-10-13 17:49:07-04:00,mmm KafkaSender . java <nl> ppp KafkaSender . java <nl> + import org . apache . kafka . clients . producer . Callback ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . Future ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . TimeoutException ; <nl> - private static final int KAFKA_SEND_TIMEOUT = 5 ; <nl> - public void send(final KafkaRecord record) { <nl> + public void send(final KafkaRecord kafkaRecord) { <nl> - try { <nl> <nl>,do not block when call kafkasender.send (,1
c641311cd7181c5afc99c1123937faec37c76d84,2015-10-16 17:03:01-04:00,"mmm DefaultRequestDispatcher . java <nl> ppp DefaultRequestDispatcher . java <nl> + import java . util . Collections ; <nl> - return new Response(method, uri, status, payload . toByteArray(), <nl> - ImmutableMap . copyOf(connection . getHeaderFields())) ; <nl> + return new Response( <nl> + method, uri, status, payload . toByteArray(), <nl> + Collections . unmodifiableMap(Maps . newHashMap(connection . getHeaderFields()))) ; <nl>",immutablemap do not suppot null key,1
5b2f56e8df41aa0b13f1c8cfe502b91db5b63f12,2015-11-12 11:54:16-05:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> - jobHistory . subList(0, Math . min(maxStates, jobHistory . size())) ; <nl> + final List<TaskStatusEvent> cappedJobHistory = jobHistory . subList( <nl> + 0, Math . min(maxStates, jobHistory . size())) ; <nl> - previousStates = Lists . transform(jobHistory, statusesToStrings) ; <nl> + previousStates = Lists . transform(cappedJobHistory, statusesToStrings) ; <nl>",fix zookeepermastermodel.getpreviousjobstates (,0
c5013131abe48c48000b45b4803fcc292d447c83,2015-11-18 16:18:56-05:00,mmm TaskMonitor . java <nl> ppp TaskMonitor . java <nl> - updateState(FAILED) ; <nl> - updateContainerError(containerError) ; <nl> + statusUpdater . setState(FAILED) ; <nl> + statusUpdater . setContainerError(containerError) ; <nl> + try { <nl> + statusUpdater . update() ; <nl> + } catch (InterruptedException e) { <nl> + Thread . currentThread() . interrupt() ; <nl> + } <nl> - private void updateContainerError(final String containerError) { <nl> - statusUpdater . setContainerError(containerError) ; <nl> - try { <nl> - statusUpdater . update() ; <nl> - } catch (InterruptedException e) { <nl> - Thread . currentThread() . interrupt() ; <nl> - } <nl>,do not bother with separate updatecontainererror method,1
d2e0d8664f9b198fec89e299896bd2c99199c92b,2015-11-30 12:49:21-05:00,mmm KafkaClientProvider . java <nl> ppp KafkaClientProvider . java <nl> - private static final int KAFKA_QUORUM_PARAMETER = 1 ; <nl> + private static final String KAFKA_QUORUM_PARAMETER = "1" ; <nl> mmm KafkaClientProviderTest . java <nl> ppp KafkaClientProviderTest . java <nl> - final KafkaClientProvider provider = new KafkaClientProvider(ImmutableList . of("localhost")) ; <nl> + final ImmutableList<String> hosts = ImmutableList . of("localhost:2181") ; <nl> + final KafkaClientProvider provider = new KafkaClientProvider(hosts) ; <nl>,fix type error in kafka_quorom_parameter,1
ed3de1a8695425d83b5f99a24e5d1f8a81ca7c42,2015-12-04 16:22:07-05:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> + import org . apache . zookeeper . OpResult ; <nl> - getDeploymentGroup(deploymentGroupName) ; <nl> - client . ensurePath(statusPath) ; <nl> + final List<ZooKeeperOperation> operations = Lists . newArrayList() ; <nl> + operations . add(set(statusPath, status)) ; <nl> - client . transaction(set(statusPath, status), <nl> - delete(tasksPath)) ; <nl> + operations . add(delete(tasksPath)) ; <nl> - client . transaction(set(statusPath, status), <nl> - create(tasksPath), <nl> - delete(tasksPath)) ; <nl> + operations . add(create(tasksPath)) ; <nl> + operations . add(delete(tasksPath)) ; <nl> + client . transaction(operations) ; <nl> - throw new DeploymentGroupDoesNotExistException(deploymentGroupName) <nl>",do not return not_found when remove a dg fail to due a race,1
d1d4e26a32c64719b8bd49ebecda35c97fc5b840,2015-12-09 16:52:21-05:00,"mmm StopDeploymentGroupTest . java <nl> ppp StopDeploymentGroupTest . java <nl> + import com . spotify . helios . servicescommon . KafkaSender ; <nl> - new ZooKeeperClientProvider(client, ZooKeeperModelReporter . noop())) ; <nl> + new ZooKeeperClientProvider(client, ZooKeeperModelReporter . noop()), <nl> + getClass() . getName(), <nl> + mock(KafkaSender . class)) ; <nl>",fix compilation error,1
dfa21def65bdde6eb925ae93f433a17aca5d0b86,2015-12-18 15:23:59-05:00,"mmm AuthenticatingHttpConnector . java <nl> ppp AuthenticatingHttpConnector . java <nl> - delegate . setExtraHttpsHandler(new CertificateFileHttpsHandler(user, clientCertificatePath)) ; <nl> + delegate . setExtraHttpsHandler( <nl> + new CertificateFileHttpsHandler(user, false, clientCertificatePath) <nl> + ) ; <nl> - delegate . setExtraHttpsHandler(new SshAgentHttpsHandler(user, agentProxy . get(), identity)) ; <nl> + delegate . setExtraHttpsHandler( <nl> + new SshAgentHttpsHandler(user, false, agentProxy . get(), identity)) ; <nl> mmm HttpsHandlers . java <nl> ppp HttpsHandlers . java <nl> - import com . spotify . helios . common . HeliosRuntimeException ; <nl> + import com . spotify . helios . client . tls . X509CertificateFactory . CertificateAndKeyPair ; <nl> <nl>",do not fail on error set up client certificate,1
1f6ceefedac6a802fa50e8f342d6dda424141e6e,2016-01-11 14:12:37-05:00,"mmm AuthenticatingHttpConnector . java <nl> ppp AuthenticatingHttpConnector . java <nl> - log . debug(""Couldn't get identities from ssh-agent"", e) ; <nl> + log . debug(""Unable to get identities from ssh-agent .  Note that this might not indicate"" <nl> + "" an actual problem unless your Helios cluster requires authentication"" <nl> + "" for all requests . "", e) ; <nl>",less-scary error message when ssh_auth_sock be not set,1
f2f453bad32b541bbdf01a5ee786decbf6da1eaa,2016-01-21 18:27:29-05:00,"mmm ZooKeeperRegistrarService . java <nl> ppp ZooKeeperRegistrarService . java <nl> - import org . apache . zookeeper . KeeperException ; <nl> - } catch (KeeperException e) { <nl> + } catch (Exception e) { <nl> + } else if (e instanceof HostNotFoundException || e instanceof HostStillInUseException) { <nl> + log . error(""ZooKeeper deregistration of old hostname failed, retrying in {} ms: {}"", <nl> + sleep, e) ; <nl> - } catch (HostNotFoundException | HostStillInUseException e) { <nl> - log . error(""ZooKeeper deregistration of old hostname failed, retrying in {} ms"", sleep, e) ; <nl>",fix zookeeperregistrarservice backoff,1
dd46dd647fb543766a8e6d4f39584fd4f7be80ab,2016-01-22 14:42:46-05:00,mmm MasterParser . java <nl> ppp MasterParser . java <nl> -  . setAgentReapingTimeout(options . getInt(agentReapingTimeout . getDest())) ; <nl> +  . setAgentReapingTimeout(options . getLong(agentReapingTimeout . getDest())) ; <nl> -  . type(Integer . class) <nl> +  . type(Long . class) <nl>,fix cli parse error,1
4d97bca734384e9283c651954e9a7c07eb0b1357,2016-01-26 14:23:11-05:00,mmm DefaultDeployer . java <nl> ppp DefaultDeployer . java <nl> + import com . spotify . helios . common . descriptors . HostStatus ; <nl> - if (Status . UP == client . hostStatus(candidateHost) . get() . getStatus()) { <nl> + final HostStatus hostStatus = client . hostStatus(candidateHost) . get() ; <nl> + if (hostStatus != null && Status . UP == hostStatus . getStatus()) { <nl> mmm DefaultDeployerTest . java <nl> ppp DefaultDeployerTest . java <nl> + import org . junit . Rule ; <nl> - import org . junit . runner . RunWith ; <nl> - import <nl>,fix occasional nullpointerexception in defaultdeployer,1
08f957cccc47efd5f838a63cb4be6138bbb2f2f6,2016-02-22 12:55:15-05:00,"mmm HeliosSoloDeployment . java <nl> ppp HeliosSoloDeployment . java <nl> + import com . spotify . docker . client . ImageNotFoundException ; <nl> - dockerClient . pull(PROBE_IMAGE) ; <nl> + pullIfAbsent(PROBE_IMAGE) ; <nl> + private void pullIfAbsent(final String image) throws DockerException, InterruptedException { <nl> + try { <nl> + dockerClient . inspectImage(image) ; <nl> + log . info(""helios-solo image {} is present .  Not pulling it . "", image) ; <nl> + return ; <nl> + } catch (ImageNotFoundException e) { <nl> + log . info(""helios-solo pulling new image: {}"", image) ; <nl> + } <nl> + dockerClient <nl>",do not pull the probe image if we already have it,1
1dda20c04fa6985a945bfde7a22504a7db91f633,2016-02-23 15:57:21-05:00,"mmm OldJobReaper . java <nl> ppp OldJobReaper . java <nl> + private final String retentionString ; <nl> + this . retentionString = DurationFormatUtils . formatDuration(retentionMillis, ""DD H:mm"") ; <nl> + final JobStatus jobStatus = masterModel . getJobStatus(jobId) ; <nl> + final Map<String, Deployment> deployments = jobStatus . getDeployments() ; <nl> - if (events . isEmpty()) { <nl> - } else { <nl> - final TaskStatusEvent event = events . get(events . size() 1) ; <nl> - final long unusedDurationMillis = clock . now() . getMillis() event . getTimestamp() ; <nl> - if (unusedDurationMillis > retentionMillis) { <nl> - final <nl>",reap not deploy job with no history,0
0001423dc04037d47b8aba79342010e163793c13,2016-02-25 12:39:21-05:00,"mmm AgentService . java <nl> ppp AgentService . java <nl> - this, config . getName(), id, config . getZooKeeperRegistrationTtlMinutes()) ; <nl> + config . getName(), id, config . getZooKeeperRegistrationTtlMinutes()) ; <nl> mmm AgentZooKeeperRegistrar . java <nl> ppp AgentZooKeeperRegistrar . java <nl> - private final Service agentService ; <nl> - public AgentZooKeeperRegistrar(final Service agentService, final String name, final String id, <nl> + public AgentZooKeeperRegistrar(final String name, final String id, <nl> - this . agentService = agentService ; <nl> - public void tryToRegister(ZooKeeperClient client) <nl> + public boolean tryToRegister(ZooKeeperClient client) <nl> - agentService . stopAsync() ; <nl> - return ; <nl> <nl>",do not signal agent registration until registration complete,1
862126ca9c4a849f9820c8c0b32ed72f764d14a8,2016-03-01 15:37:20-05:00,mmm ZooKeeperRegistrarService . java <nl> ppp ZooKeeperRegistrarService . java <nl> - this . zkRegistrationSignal = builder . zkRegistrationSignal ; <nl> + this . zkRegistrationSignal = Optional . ofNullable(builder . zkRegistrationSignal) ; <nl> - private Optional<CountDownLatch> zkRegistrationSignal ; <nl> + private CountDownLatch zkRegistrationSignal ; <nl> - this . zkRegistrationSignal = Optional . of(zkRegistrationSignal) ; <nl> + this . zkRegistrationSignal = zkRegistrationSignal ; <nl>,fix npe in master zookeeper registrar,1
2a9572a931e128023f160804cad2b5451335e774,2016-04-25 13:06:57-04:00,mmm JobCreateCommand . java <nl> ppp JobCreateCommand . java <nl> - import com . google . common . annotations . VisibleForTesting ; <nl> - import com . google . common . base . Supplier ; <nl> - import com . google . common . collect . ImmutableList ; <nl> - import com . google . common . collect . ImmutableMap ; <nl> - import com . google . common . collect . ImmutableMap . Builder ; <nl> - import com . google . common . collect . Iterables ; <nl> - import com . google . common . collect <nl>,fix jobcreatecommand : do not overwrite capability from json file,1
a51605fb870c0b7a12def7cee616a721b983c8ff,2016-04-25 14:45:04-04:00,"mmm HostSelector . java <nl> ppp HostSelector . java <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Sets ; <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> - final String[] parts = ((String) b) . replaceAll(""(\\(|\\)| )"", """") . split("","") ; <nl> - for (final String part : parts) { <nl> - if (part . equals(a)) { <nl> - <nl>",fix equality comparison of in and notin host selector,1
db97eb95095c06e62b86730dd8222136bd483c4a,2016-05-05 16:18:16-04:00,"mmm HeliosDeploymentResource . java <nl> ppp HeliosDeploymentResource . java <nl> + import com . spotify . helios . common . descriptors . HostStatus ; <nl> - if (!hosts . isEmpty()) { <nl> - log . info(""Ensured that at least one agent is available in this HeliosDeployment, "" <nl> + if (hosts . isEmpty()) { <nl> + log . debug(""0 agents in {}, will retry"", deployment) ; <nl> + return null ; <nl> + } <nl> + log . info(""Ensured that at least one agent has registered with ZooKeeper in this"" <nl> + ""HeliosDeployment .  Now checking if it <nl>",ensure helios-solo agent be up,1
17aad0b4ffade25bcde3fe006dc1df1fc9fd93b4,2016-06-06 09:30:57-04:00,"mmm DeploymentGroup . java <nl> ppp DeploymentGroup . java <nl> + public enum RollingUpdateReason { <nl> + MANUAL, <nl> + HOSTS_CHANGED <nl> + } <nl> + private final RollingUpdateReason reason ; <nl> - @JsonProperty(""rolloutOptions"") @Nullable final RolloutOptions rolloutOptions) { <nl> + @JsonProperty(""rolloutOptions"") @Nullable final RolloutOptions rolloutOptions, <nl> + @JsonProperty(""rollingUpdateReason"") @Nullable final RollingUpdateReason reason) { <nl> + this . reason = reason ; <nl> + public RollingUpdateReason getRollingUpdateReason() { <nl> + return reason ; <nl> + } <nl> + if (reason != null ? !reason . equals(that . reason) : that . reason != null) { <nl> + return false <nl>",do not block roll update when new host fail to update,1
1384d36e925f9d5ddc3f3445d4e372de991e19b7,2016-06-06 09:30:57-04:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> + import static com . spotify . helios . common . descriptors . DeploymentGroupStatus . State . ROLLING_OUT ; <nl> - private boolean updateOnHostChange(final DeploymentGroup group) <nl> - throws DeploymentGroupDoesNotExistException { <nl> - final DeploymentGroupStatus status = getDeploymentGroupStatus(group . getName()) ; <nl> + private boolean allowHostChange(final DeploymentGroupStatus status) { <nl> + if (status == null) { <nl> + return true ; <nl> + } <nl> + return status . getState() != ROLLING_OUT ; <nl> + } <nl> + private boolean updateOnHostChange(final DeploymentGroup group, <nl> + final DeploymentGroupStatus status) { <nl>",do not allow host to change when deployment group be roll out,1
bc60d7519d13e710a3701be5d8446ca4d01535a0,2016-08-31 15:26:20-04:00,"mmm Supervisor . java <nl> ppp Supervisor . java <nl> - final Integer gracePeriod = job . getGracePeriod() ; <nl> - if (gracePeriod != null && gracePeriod > 0) { <nl> - log . info(""Unregistering from service discovery for {} seconds before stopping"", <nl> - gracePeriod) ; <nl> - if (runner . unregister()) { <nl> - log . info(""Unregistered .  Now sleeping for {} seconds . "", gracePeriod) ; <nl> - sleeper . sleep(TimeUnit . MILLISECONDS . convert(gracePeriod, TimeUnit . SECONDS)) ; <nl> + if (runner != null) { <nl> + final Integer gracePeriod = job . getGracePeriod() <nl>",fix npe in supervisor.stop when job have graceperiod,1
11c8ce757075d1f9e29daf1f93a58480df113488,2016-10-06 14:30:59-04:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> - log . error(""unable to mark host undeployed after removal from deployment group: "" <nl> - + ""deployment-group={}, host={}"", deploymentGroup . getName(), host, e) ; <nl> - return opFactory . nextTask() ; <nl> + return opFactory . error(""unable to mark host undeployed after removal from deployment group"", <nl> + host, RollingUpdateError . UNABLE_TO_MARK_HOST_UNDEPLOYED) ; <nl> mmm RollingUpdateError . java <nl> ppp RollingUpdateError . java <nl> + UNABLE_TO_MARK_HOST_UNDEPLOYED, <nl>",return an error when we can not read host to mark them undeployed,1
67a471523cc2ffd734089dda690478849fd52890,2016-10-26 18:32:33-04:00,"mmm HeliosSoloLogService . java <nl> ppp HeliosSoloLogService . java <nl> - import com . google . common . io . Closer ; <nl> + import com . spotify . docker . client . exceptions . DockerException ; <nl> - public Void call() throws IOException { <nl> - final Closer closer = Closer . create() ; <nl> - try { <nl> - final LogStream logStream = <nl> - closer . register(dockerClient . logs(containerId, stdout(), stderr(), follow())) ; <nl> + public Void call() throws IOException, DockerException { <nl> + try (final LogStream logStream = <nl> + dockerClient . logs(containerId, stdout(), stderr(), <nl>","do not use closer , it 's not java 6 any more",1
0ff015494ef15b24f34f22fcfbdb43e02ff5c026,2016-10-31 13:44:26-04:00,"mmm InMemoryLogStreamFollower . java <nl> ppp InMemoryLogStreamFollower . java <nl> + import java . io . OutputStream ; <nl> - assert content . hasArray() ; <nl> - stdout . write(content . array(), content . position(), content . remaining()) ; <nl> - stdout . flush() ; <nl> + writeAndFlush(content, stdout) ; <nl> - stderr . write(content . array(), content . position(), content . remaining()) ; <nl> - stderr . flush() ; <nl> + writeAndFlush(content, stderr) ; <nl> + private static void writeAndFlush( <nl> + final ByteBuffer buffer, final OutputStream outputStream) throws IOException { <nl> + if (buffer . hasArray()) { <nl>",fix assertionerror in inmemorylogstreamfollower,0
dfb3bac3f2cc6e7b2b54e3b97e9abaccf2daf7cd,2016-12-06 13:50:42-05:00,"mmm HostMatcher . java <nl> ppp HostMatcher . java <nl> + if (hostLabels == null) { <nl> + continue ; <nl> + } <nl> mmm HostsResource . java <nl> ppp HostsResource . java <nl> + import static java . util . Collections . emptyMap ; <nl> - final Map<String, Map<String, String>> hostsAndLabels = hosts . stream() <nl> -  . collect(Collectors . toMap(Function . identity(), <nl> - host -> model . getHostStatus(host) . getLabels() <nl> - ) <nl> - ) ; <nl> + final Map<String, Map<String, String>> hostsAndLabels = getLabels(hosts) ; <nl> + private Map<String, Map<String, String>> getLabels(final List<String> <nl>",fix npe in hostsresource,1
23dafe486d9d1d14709e39c116e2d1a04c307be2,2016-12-09 12:48:47-05:00,"mmm ZooKeeperMasterModel . java <nl> ppp ZooKeeperMasterModel . java <nl> + import java . util . stream . Collectors ; <nl> + final List<String> upHostsToUndeploy = undeployHostsCopy . stream() <nl> +  . filter(host -> checkHostUp(zooKeeperClient, host)) <nl> +  . collect(Collectors . toList()) ; <nl> + final List<String> upHostsToDeploy = updateHostsCopy . stream() <nl> +  . filter(host -> checkHostUp(zooKeeperClient, host)) <nl> +  . collect(Collectors . toList()) ; <nl> -  . plan(getHostStatuses(undeployHostsCopy))) ; <nl> +  . plan(upHostsToUndeploy)) ; <nl> -  . plan(getHostStatuses(updateHostsCopy))) ; <nl> +  . plan(upHostsToDeploy)) ; <nl> - private Map<String, HostStatus> <nl>",do not get host status when we do not need to,0
8ddb6d7ae86565116f713aa492e27e4c32cb5d00,2017-01-26 13:27:27-05:00,"mmm JobValidator . java <nl> ppp JobValidator . java <nl> + if (servicePorts == null || servicePorts . getPorts() == null) { <nl> + errors . add(format(""registration for '%s' is malformed: does not have a port mapping"", <nl> + registration . getName())) ; <nl> + continue ; <nl> + } <nl> mmm JobValidatorTest . java <nl> ppp JobValidatorTest . java <nl> + import static com . google . common . base . Charsets . UTF_8 ; <nl> + import com . google . common . io . Resources ; <nl> + import java . net . URL ; <nl> <nl>",fix npe if job have malformed registration,1
30b260818e8d3933a44c4a47584ff14f28810e7a,2017-04-10 13:09:38-04:00,mmm RollingUpdateOpFactory . java <nl> ppp RollingUpdateOpFactory . java <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + private static final Logger log = LoggerFactory . getLogger(RollingUpdateOpFactory . class) ; <nl> + private boolean isIgnoreFailures() { <nl> + return deploymentGroup . getRolloutOptions() != null <nl> + && deploymentGroup . getRolloutOptions() . getIgnoreFailures() ; <nl> + } <nl> + if (isIgnoreFailures()) { <nl> + log . info( <nl> + "would have set state=FAILED for deploymentGroup={} but ignoreFailures is set to true " <nl> + "for this group/rollout .  <nl>,do not set deploymentgroup to fail when ignorefailure be true,1
c8e9f5a3dfea35da0b4c899cdd388c3d70fe56c6,2017-07-06 10:49:13+02:00,"mmm JobValidator . java <nl> ppp JobValidator . java <nl> + final Set<String> volumeMountPoints = Sets . newHashSet() ; <nl> + for (String s : job . getVolumes() . keySet()) { <nl> + volumeMountPoints . add(s . split("":"", 2)[0]) ; <nl> + } <nl> + for (final String mountPoint : job . getRamdisks() . keySet()) { <nl> + if (volumeMountPoints . contains(mountPoint)) { <nl> + errors . add(format(""Ramdisk mount point used by volume: %s"", mountPoint)) ; <nl> + } <nl> + } <nl> mmm JobValidatorTest . java <nl> ppp JobValidatorTest . java <nl> - import static com . google <nl>",do not allow mount point to be reuse between ramdisks and volume,1
9d6331732d6276e1208d3d717c009dd7047d2e26,2017-11-08 13:31:25-05:00,"mmm RollingUpdateCommand . java <nl> ppp RollingUpdateCommand . java <nl> + import com . google . common . base . MoreObjects ; <nl> - final RolloutOptions optionsFromJob = job . getRolloutOptions() ; <nl> + final RolloutOptions optionsFromJob = <nl> + MoreObjects . firstNonNull(job . getRolloutOptions(), RolloutOptions . getDefault()) ; <nl> mmm RollingUpdateCommandTest . java <nl> ppp RollingUpdateCommandTest . java <nl> + import static org . hamcrest . CoreMatchers . equalTo ; <nl> + @Test <nl> + public void testJobWithNoOptions() throws Exception { <nl> + final JobId jobId = new JobId(""bar"", ""2"", ""1212121212121212121"") ; <nl> + final Job job = <nl>",fix npe in rolling-update command,1
d60d7932a3a45bd6fbad2423452ad0d91ddb7ce5,2018-08-28 10:04:51-04:00,mmm OldJobReaper . java <nl> ppp OldJobReaper . java <nl> + import com . spotify . helios . common . descriptors . DeploymentGroup ; <nl> + import java . util . Set ; <nl> + import java . util . stream . Collectors ; <nl> + private Set<JobId> jobsInDeploymentGroups ; <nl> + @Override <nl> + protected void beforeIteration() { <nl> + jobsInDeploymentGroups = masterModel . getDeploymentGroups() <nl> +  . values() <nl> +  . stream() <nl> +  . map(DeploymentGroup::getJobId) <nl> +  . collect(Collectors . toSet()) ; <nl> + } <nl> - if (unusedDurationMillis > retentionMillis) { <nl>,do not reap job that be part of a deploymentgroup,0
66b647e51deff1cb5648f9b1820bd358a9168047,2019-09-11 10:57:23-04:00,"mmm ExpiredJobReaper . java <nl> ppp ExpiredJobReaper . java <nl> + if (status == null) { <nl> + log . warn(""Couldn't find job status for {} because job has already been deleted . "" <nl> + ""Skipping . "", jobId) ; <nl> + return ; <nl> + } <nl> mmm OldJobReaper . java <nl> ppp OldJobReaper . java <nl> + if (jobStatus == null) { <nl> + log . warn(""Couldn't find job status for {} because job has already been deleted .  Skipping . "", <nl> + jobId) ; <nl> + return ; <nl> + } <nl>",fix npe in oldjobreaper,1
2e80464382c5be4795347c421add89dc785004c3,2011-04-26 14:46:28+02:00,"mmm HotSpotXirGenerator . java <nl> ppp HotSpotXirGenerator . java <nl> - private CiXirAssembler asm ; <nl> + private CiXirAssembler globalAsm ; <nl> - private XirOperand genArrayLength(XirOperand array, boolean implicitNullException) { <nl> + private XirOperand genArrayLength(CiXirAssembler asm, XirOperand array, boolean implicitNullException) { <nl> + asm . nop(1) ; <nl> - length = genArrayLength(array, implicitNullException) ; <nl> + length = genArrayLength(asm, array, implicitNullException) ; <nl> - this . asm = asm ; <nl> + this . globalAsm = asm ; <nl> - template = create(HotSpotXirGenerator . this . asm . copy(), flags) ; <nl> + template = create(HotSpotXirGenerator . this . <nl>",fix an issue in the hotspot xir generator benchmark `` fop '' now pass on all optimization level,1
d09ac1743689a79f2aebcdf1229f16693c527399,2011-05-11 16:25:15+02:00,"mmm HotSpotVMConfig . java <nl> ppp HotSpotVMConfig . java <nl> - public long throwClassCastException ; <nl> - public long throwArrayStoreException ; <nl> - public long throwArrayIndexException ; <nl> mmm HotSpotXirGenerator . java <nl> ppp HotSpotXirGenerator . java <nl> - asm . callRuntime(config . throwArrayIndexException, null) ; <nl> + asm . callRuntime(CiRuntimeCall . Deoptimize, null) ; <nl> - asm . callRuntime(config . throwArrayStoreException, null) ; <nl> + asm . callRuntime(CiRuntimeCall . Deoptimize, null) ; <nl> - asm . callRuntime(config . throwArrayIndexException, null) ; <nl> + asm . callRuntime(CiRuntimeCall . Deoptimize, null) ; <nl> - asm . callRuntime(config . throwArrayStoreException, null) <nl>",deoptimize on array store and array bound exception,1
ff1dd0c0e0c337a354ff2d373bc3a87dc66f30c0,2011-05-23 21:21:47+02:00,"mmm LIRGenerator . java <nl> ppp LIRGenerator . java <nl> - void moveToPhi(PhiResolver resolver, Value curVal, Value suxVal) { <nl> + void moveToPhi(PhiResolver resolver, Value curVal, Value suxVal, List<Phi> phis, int predIndex) { <nl> + assert phis . contains(phi) ; <nl> + if (phi . valueAt(predIndex) != curVal) { <nl> + phi . print(TTY . out()) ; <nl> + } <nl> + assert phi . valueAt(predIndex) == curVal : ""curVal="" curVal ""valueAt("" predIndex "")="" phi . valueAt(predIndex) ; <nl> - if (phis != null) { <nl> - int predIndex = 0 ; <nl> - for ( ; predIndex < <nl>",fix several issue with incorrect predecessor count/order one known issue around exception dispatch remain in fop,1
f80204f82b2a2d69f07b27113f03e28075a86d88,2011-05-30 18:01:32+02:00,"mmm LIRGenerator . java <nl> ppp LIRGenerator . java <nl> - int length = 3 ; <nl> + return invoke . bci ; <nl> mmm GraphBuilder . java <nl> ppp GraphBuilder . java <nl> - Invoke invoke = new Invoke(opcode, resultType . stackKind(), args, target, target . signature() . returnType(compilation . method . holder()), graph) ; <nl> + Invoke invoke = new Invoke(opcode, resultType . stackKind(), args, target, target . signature() . returnType(compilation . method . holder()), graph, bci()) ; <nl> mmm Invoke . java <nl> ppp Invoke . java <nl> + public final int bci ; // XXX <nl>",fix invoke bci problem,0
df8dee6dade629cdf29acaa6b4b32233418254c2,2011-06-08 17:07:06+02:00,"mmm GraalOptions . java <nl> ppp GraalOptions . java <nl> - public static boolean Inline                             = ____ ; <nl> + public static boolean Inline                             = true ; <nl> mmm IR . java <nl> ppp IR . java <nl> - new GraphBuilderPhase(compilation, compilation . <nl>",ensure that only one phase timer be run at one time,1
da6c7f44632a30a2b9b55744f7177bdea151525a,2011-06-15 17:13:34+02:00,"mmm Graph . java <nl> ppp Graph . java <nl> + for (Entry<Node, Node> entry : newNodes . entrySet()) { <nl> + Node oldNode = entry . getKey() ; <nl> + Node node = entry . getValue() ; <nl> + for (int i = 0 ; i < oldNode . successors() . size() ; i++) { <nl> + Node succ = oldNode . successors() . get(i) ; <nl> + Node target = replacements . get(succ) ; <nl> + if (target == null) { <nl> + target = newNodes . get(succ) ; <nl> + } <nl> + node . successors() <nl>",do not care about predecessor order when duplicate node,1
63f1a2f95bd2ef8ab195d84aa62f8cc30ed7cda5,2011-06-21 12:01:28+02:00,mmm GraalOptions . java <nl> ppp GraalOptions . java <nl> + public static boolean UseExceptionProbability            = true ; <nl> + public static int     MatureInvocationCount              = 100 ; <nl> mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> - if (exceptionObject == null && method . exceptionProbability(bci) == 0) { <nl> - return null ; <nl> + if (GraalOptions . UseExceptionProbability && method . invocationCount() > GraalOptions . MatureInvocationCount) { <nl> <nl>,fix on exception profiling,0
42a94b564c199cabd3b41588131d2eb0ec6d8621,2011-06-30 18:03:43+02:00,"mmm HotSpotXirGenerator . java <nl> ppp HotSpotXirGenerator . java <nl> - XirOperand result = asm . restart(CiKind . Boolean) ; <nl> + asm . restart(CiKind . Void) ; <nl> - asm . mov(result, asm . b(true)) ; <nl> - checkSubtype(asm, result, objHub, hub) ; <nl> - asm . jeq(falseSucc, result, asm . b(false)) ; <nl> + checkSubtype(asm, objHub, objHub, hub) ; <nl> + asm . jeq(falseSucc, objHub, asm . o(null)) ; <nl>",optimize geninstanceof xir snippet,1
99c1f45f0de16d5c1bb3b238c6918bb6de90055b,2011-06-30 18:39:13+02:00,"mmm CheckCast . java <nl> ppp CheckCast . java <nl> - @Override <nl> - public int valueNumber() { <nl> - return targetClass() . isResolved() ? Util . hash1(Bytecodes . CHECKCAST, object()) : 0 ; <nl> - } <nl> - @Override <nl> - public boolean valueEqual(Node i) { <nl> - return i instanceof CheckCast ; <nl> - } <nl> mmm FixedGuard . java <nl> ppp FixedGuard . java <nl> - public FixedGuard(Graph graph) { <nl> + public FixedGuard(BooleanNode node, Graph graph) { <nl> + setNode(node) ; <nl> - return new FixedGuard(into) ; <nl> + return new FixedGuard(null, into) ; <nl> <nl>",must not gvn checkcast instruction,0
2fafed534ac3645174f99edfd463493e137632b5,2011-07-06 21:43:07+02:00,mmm Block . java <nl> ppp Block . java <nl> - } else if (firstNode instanceof Merge) {,fix anchor creation such that exception handler block be recognize,1
85d5157f50d9835b767037340a6836934c8756a6,2011-07-08 14:49:01+02:00,mmm LoopUtil . java <nl> ppp LoopUtil . java <nl> - || (!inOrBefore . isNew(n) && !inOrBefore . isMarked(n) && n . inputs() . size() > 0 && !danglingMergeFrameState(n)) ; //TODO (gd) hum <nl> + || (!inOrBefore . isNew(n) && !inOrBefore . isMarked(n) && n . inputs() . size() > 0 && !afterColoringFramestate(n)) ; //TODO (gd) hum <nl> - public boolean danglingMergeFrameState(Node n) { <nl> + public boolean afterColoringFramestate(Node n) { <nl> - Merge block = ((FrameState) n) . block() ; <nl> - return block != null && colors . get(block . next()) == null ; <nl> + final <nl>,fix for peel spliting : inner framestates which be attach to node after the coloring can not be color,1
e35bffa4149441f1e5f5eba182be1a48ed4a36fe,2011-12-29 14:05:08-08:00,"mmm VMExitsNative . java <nl> ppp VMExitsNative . java <nl> - while (compileQueue . getCompletedTaskCount() < compileQueue . getTaskCount()) { <nl> + while (compileQueue . getCompletedTaskCount() < Math . max(2, compileQueue . getTaskCount())) { <nl>",ensure bootstrapping wait until method be compile,1
3fc1e79eb1eb64d5ce6a8c2cefa5c943ea88b4da,2012-01-17 15:26:59+01:00,"mmm GraalCompiler . java <nl> ppp GraalCompiler . java <nl> - } catch (CiBailout bailout) { <nl> - throw bailout ; <nl> + } catch (CiBailout | GraalInternalError exception) { <nl> + throw exception ; <nl> mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> + CompareNode condition = currentGraph . unique(new CompareNode(x, cond, y)) ; <nl> - append(currentGraph . add(new IfNode(currentGraph . unique(new CompareNode(x, cond, y)), trueSuccessor, falseSuccessor, probability))) ; <nl> + if (trueSuccessor == falseSuccessor) { <nl> + appendGoto(trueSuccessor) ; <nl> + } else { <nl> + append(currentGraph . add(new IfNode(condition, trueSuccessor, falseSuccessor, probability))) ; <nl> <nl>","small fix : do not cascade graalinternalerrors , convert useless ifs to gotos",1
79a9a364b28bead4d16d3bb7731c3693e8b302c2,2012-01-17 19:35:29-08:00,"mmm LIRVerifier . java <nl> ppp LIRVerifier . java <nl> + private BitSet curRegistersDefined ; <nl> + curRegistersDefined = new BitSet() ; <nl> + curRegistersDefined . clear() ; <nl> - if (mode == OperandMode . Output) { <nl> - curRegistersLive[regNum] = value ; <nl> - } else { <nl> - curRegistersLive[regNum] = null ; <nl> + if (curRegistersDefined . get(regNum)) { <nl> + TTY . println(""block %s  instruction %s"", curBlock, curInstruction) ; <nl> + TTY . println(""ERROR: Same register defined twice in the same instruction: %s"", value) ; <nl> + throw Util . shouldNotReachHere() ; <nl> + } <nl>",enforce that one fix register can not be a temporary operand multiple time with different kind,1
efff5e7ac71fda0025357b04aff380c35f4415f3,2012-02-02 20:45:36-08:00,"mmm CanonicalizerPhase . java <nl> ppp CanonicalizerPhase . java <nl> - if (stateAfter . usages() . isEmpty()) { <nl> + if (stateAfter != null && stateAfter . usages() . isEmpty()) { <nl> mmm InliningUtil . java <nl> ppp InliningUtil . java <nl> - builder . append(CiUtil . format(""\n        %H . %n(%p):%r"", concretes . get(i))) ; <nl> + builder . append(CiUtil . format(""  %H . %n(%p):%r"", concretes . get(i))) ; <nl> + if (notRecordedTypeProbability > 0) { <nl> + Debug . log(""not inlining %s because not all seen types were could be <nl>",inlining seem stable but deoptimizes too frequently,1
657ad94af16abebc992d7bacef500aeff49c959f,2012-02-07 12:09:11-08:00,"new file <nl> ppp RiExceptionSeen . java <nl> + package com . oracle . max . cri . ri ; <nl> + public enum RiExceptionSeen { <nl> + TRUE, <nl> + FALSE, <nl> + UNKNOWN ; <nl> + public static RiExceptionSeen get(boolean value) { <nl> + return value ? TRUE : FALSE ; <nl> + } <nl> + } <nl> mmm RiProfilingInfo . java <nl> ppp RiProfilingInfo . java <nl> - boolean getExceptionSeen(int bci) ; <nl> + RiExceptionSeen getExceptionSeen(int bci) ; <nl> mmm RiResolvedMethod . java <nl> ppp RiResolvedMethod . java <nl> + void dumpProfile() ; <nl> mmm HotSpotMethodData <nl>",fix exceptionseen profile information,0
5e9c87492c8498efd58af9de5960e988c163fdb3,2012-02-08 20:30:47-08:00,"mmm GraalOptions . java <nl> ppp GraalOptions . java <nl> - public static int     MaximumInlineLevel                 = 9 ; <nl> + public static int     MaximumInlineLevel                 = 30 ; <nl> mmm InliningUtil . java <nl> ppp InliningUtil . java <nl> + FrameState stateAfter = exceptionObject . stateAfter() ; <nl> + newExceptionObject . setStateAfter(stateAfter . duplicateModified(stateAfter . bci, stateAfter . rethrowException(), CiKind <nl>",fix exception framestate,1
066a490b8aeb1d2a3f3f52229f8ee1113a65b439,2012-02-09 13:21:42+01:00,mmm CFGPrinterObserver . java <nl> ppp CFGPrinterObserver . java <nl> - } else if (object instanceof LIRGenerator) { <nl> - cfgPrinter . lirGenerator = (LIRGenerator) object ; <nl> - return ; <nl> - if (object instanceof RiResolvedMethod) { <nl> + if (object instanceof LIRGenerator) { <nl> + cfgPrinter . lirGenerator = (LIRGenerator) object ; <nl> + } else if (object instanceof RiResolvedMethod) { <nl>,fix an other npe in cfgprinterobserver,1
6a1ee0afd7c30b547b8ff9a4677481750c16c6f9,2012-02-09 17:03:44-08:00,mmm HotSpotMethodData . java <nl> ppp HotSpotMethodData . java <nl> - if (position >= extraDataSize) { <nl> + if (position >= normalDataSize extraDataSize) { <nl> mmm BciBlockMapping . java <nl> ppp BciBlockMapping . java <nl> - case INVOKESTATIC: <nl> - case INVOKESPECIAL: <nl> - case INVOKEVIRTUAL: <nl> - case INVOKEINTERFACE: { <nl> - return true ; <nl> - } <nl>,fix another endless recompilation,1
e9d4236a6c869f930337b335b614404e5d8f2514,2012-02-16 18:30:39+01:00,"mmm HotSpotMethodResolvedImpl . java <nl> ppp HotSpotMethodResolvedImpl . java <nl> - return holder . toJava() . getDeclaredMethod(name, CiUtil . signatureToTypes(signature, holder)) ; <nl> + return holder . toJava() . getDeclaredMethod(name, CiUtil . signatureToTypes(signature(), holder)) ; <nl> - return holder . toJava() . getDeclaredConstructor(CiUtil . signatureToTypes(signature, holder)) ; <nl> + return holder . toJava() . getDeclaredConstructor(CiUtil . signatureToTypes(signature(), holder)) ; <nl>",fix possible nullpointerexception in hotspotmethodresolveimpl.tojava,1
e4f179b906fea073d01fc2b1372cb0bf23a8f01d,2012-02-19 04:28:40+01:00,mmm DebugValueMap . java <nl> ppp DebugValueMap . java <nl> - List<DebugValueMap> oldChildren = new ArrayList<>(this . children) ; <nl> - this . children . clear() ; <nl> - for (DebugValueMap map : oldChildren) { <nl> - mergeWith(map) ; <nl> + if (this . hasChildren()) { <nl> + List<DebugValueMap> oldChildren = new ArrayList<>(this . children) ; <nl> + this . children . clear() ; <nl> + for (DebugValueMap map : oldChildren) { <nl> + mergeWith(map) ; <nl> + } <nl>,fix npe in debugvaluemap.group,1
52eec4c2e94da8156b3e24a488dafed360bdf6de,2012-02-21 16:35:42+01:00,mmm ConstantNode . java <nl> ppp ConstantNode . java <nl> + import com . oracle . max . graal . graph . iterators . * ; <nl> - if (gen . canInlineConstant(value)) { <nl> + if (gen . canInlineConstant(value) || onlyUsedInFrameState()) { <nl> + private boolean onlyUsedInFrameState() { <nl> + return usages() . filter(NodePredicates . isNotA(FrameState . class)) . isEmpty() ; <nl> + } <nl>,do not emit move for constant that be use only in frame state,1
b0e6a5e8682f75750a574e8b075c123a6d49be7f,2012-02-28 21:25:21+01:00,mmm DebugScope . java <nl> ppp DebugScope . java <nl> - private static DebugMetric scopeCount = Debug . metric("ScopeCount") ; <nl> - private List<DebugScope> children ; <nl> - scopeCount . increment() ; <nl> - if (children == null) { <nl> - children = new ArrayList<>(4) ; <nl> - } <nl> - children . add(result) ; <nl>,fix debugscope memory leak,1
5e07f64c48be896dba5700dd9ce1c76383852b14,2012-03-02 09:06:31-08:00,mmm ArrayCopySnippets . java <nl> ppp ArrayCopySnippets . java <nl> - long header = ArrayHeaderSizeNode . sizeFor(CiKind . Short) ; <nl> + long header = ArrayHeaderSizeNode . sizeFor(CiKind . Int) ; <nl> - long header = ArrayHeaderSizeNode . sizeFor(CiKind . Short) ; <nl> + long header = ArrayHeaderSizeNode . sizeFor(CiKind . Long) ; <nl>,fix copy & paste error,1
9eb261a4018b1d12dea9623e35e723e7f451ce01,2012-03-07 11:06:14-08:00,mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> - if (probability == 0) { <nl> - FrameStateBuilder state = stateAfter . copy() ; <nl> - state . clearNonLiveLocals(block . localsLiveIn) ; <nl> + if (probability == 0 && config . useBranchPrediction()) { <nl> - begin . setStateAfter(state . create(block . startBci)) ; <nl>,"fix performance regression : when never execute code be not compile , deoptimize before the branch so that interpreter update profile information",1
096dfa250e27b908c90b18669aaf1824624bac74,2012-03-07 14:14:03-08:00,"mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> - appendGoto(createBlockTarget(probability, currentBlock . successors . get(0), frameState)) ; <nl> + appendGoto(createTarget(probability, currentBlock . successors . get(0), frameState)) ; <nl> + private FixedNode createTarget(double probability, Block block, FrameStateBuilder stateAfter) { <nl> + assert probability >= 0 && probability <= 1 ; <nl> + if (probability == 0 && config . useBranchPrediction()) { <nl> + BeginNode begin = currentGraph . add(new BeginNode()) ; <nl> + DeoptimizeNode deopt = currentGraph . add(new DeoptimizeNode(DeoptAction . InvalidateReprofile)) ; <nl> + begin . setNext(deopt) ; <nl> + return begin ; <nl> + } else <nl>",another fix for goto 's deopt case,0
c4aa6f6c33ffcbb084740f689c0aff9dffb2ef9c,2012-03-13 12:01:24-07:00,mmm BciBlockMapping . java <nl> ppp BciBlockMapping . java <nl> - if (GraalOptions . AllowExplicitExceptionChecks && profilingInfo . getExceptionSeen(bci) != RiExceptionSeen . FALSE) { <nl> + if (GraalOptions . AllowExplicitExceptionChecks && (!GraalOptions . UseExceptionProbability || profilingInfo . getExceptionSeen(bci) != RiExceptionSeen . FALSE)) { <nl> mmm GraphBuilderConfiguration . java <nl> ppp GraphBuilderConfiguration . java <nl> - import com . oracle . max . cri . ri . * ; <nl> - import com . oracle . graal . compiler . * ; <nl> + import com . oracle . max . cri . ri . * ; <nl> - private <nl>,fix case when exception probability should not be use,1
090533809c03ed2d651d91cd66a093b7350fc47f,2012-03-16 19:23:43+01:00,"mmm ConvertDeoptimizeToGuardPhase . java <nl> ppp ConvertDeoptimizeToGuardPhase . java <nl> - visitDeoptBranch(findBeginNode(d), d, graph) ; <nl> + visitDeoptBegin(findBeginNode(d), d, graph) ; <nl> - private void visitDeoptBranch(BeginNode deoptBegin, DeoptimizeNode deopt, StructuredGraph graph) { <nl> + private void visitDeoptBegin(BeginNode deoptBegin, DeoptimizeNode deopt, StructuredGraph graph) { <nl> - Debug . log(""Eliminating %s followed by %s"", mergeNode, deopt) ; <nl> + Debug . log(""Visiting %s followed by %s"", mergeNode, deopt) ; <nl> - visitDeoptBranch(beginNode, deopt, graph) ; <nl> + if (!(beginNode instanceof MergeNode)) { <nl> + visitDeoptBegin(beginNode, deopt, graph) ; <nl> + } <nl> - if (!deopt . isDeleted()) { <nl> - visitDeoptBranch(findBeginNode(deopt), <nl>",fix possible endless recursion in convertdeoptimizetoguardphase,1
b0a616d6631616c8937a3a28e7d3c0b49ae96683,2012-03-16 19:30:11+01:00,mmm InvokeWithExceptionNode . java <nl> ppp InvokeWithExceptionNode . java <nl> + } else if (node instanceof DeoptimizeNode) { <nl> + this . replaceAtPredecessors(node) ; <nl> + this . replaceAtUsages(null) ; <nl> + GraphUtil . killCFG(this) ; <nl> + return ; <nl>,fix intrinsification of an invoke with exception with a deoptimize node,1
01cf805f7617cac56f33f8b9afe15ac32af858e4,2012-03-21 12:11:51+01:00,"mmm DeoptimizeNode . java <nl> ppp DeoptimizeNode . java <nl> + @SuppressWarnings(""unused"") <nl> - public static void deopt() { <nl> + public static void deopt(@ConstantNodeParameter RiDeoptAction action, @ConstantNodeParameter RiDeoptReason reason) { <nl>",fix deoptimizenode.deopt intrinsic,0
f9fd1dd12c4ac81248ae29ff0ece5c12c570a63d,2012-04-06 15:44:15+02:00,mmm GraphUtil . java <nl> ppp GraphUtil . java <nl> + import com . oracle . graal . graph . iterators . * ; <nl> + import com . oracle . graal . nodes . virtual . * ; <nl> - for (Node successor : node . successors() . snapshot()) { <nl> + for (Node successor : node . successors()) { <nl> + StructuredGraph graph = (StructuredGraph) end . graph() ; <nl> - ((StructuredGraph) end . graph()) . reduceDegenerateLoopBegin((LoopBeginNode) merge) ; <nl> + graph . reduceDegenerateLoopBegin((LoopBeginNode) merge) ; <nl> - ((StructuredGraph) end . graph()) . reduceTrivialMerge(merge) ; <nl> + <nl>,fix potential killcfg problem,1
ef2c8b4fc3b1195583e2e704a342040953e015c0,2012-04-13 23:28:20+02:00,"mmm LIRGenerator . java <nl> ppp LIRGenerator . java <nl> - XirSnippet snippet = xir . genExceptionObject(site(x)) ; <nl> - LIRDebugInfo info = state() ; <nl> - emitXir(snippet, x, info, true) ; <nl> + throw new GraalInternalError(""Runtime must provide lowering for "" x) ; <nl> mmm LoweringPhase . java <nl> ppp LoweringPhase . java <nl> + import com . oracle . graal . nodes . java . * ; <nl> - assert !(node instanceof FixedNode) || node . predecessor() == null ; <nl> + assert !(node instanceof FixedNode) || node instanceof ExceptionObjectNode || node . predecessor() == null ; <nl>",exceptionobjectnode be now lower without xir,1
45f89359152ebd39d85b728ddbf65f3f06b9f8c0,2012-04-23 21:27:48+02:00,mmm LoopSafepointInsertionPhase . java <nl> ppp LoopSafepointInsertionPhase . java <nl> + if (!loopEnd . canSafepoint()) { <nl> + continue ; <nl> + } <nl> mmm LoopEndNode . java <nl> ppp LoopEndNode . java <nl> + @Data private boolean canSafepoint ; <nl> + this . canSafepoint = true ; <nl> + public void disableSafepoint() { <nl> + this . canSafepoint = false ; <nl> + } <nl> + public boolean canSafepoint() { <nl> + if (!canSafepoint) { <nl> + return canSafepoint ; <nl> + } <nl> + return canSafepoint ; <nl> + } <nl> mmm SafepointNode . java <nl> ppp <nl>,fix regression : loop safepoints can not be place inside snippet,1
2ee1a3af9d9b0598f13ea2fcbff0786d8949b788,2012-05-18 15:49:23+02:00,mmm IndexedLocationNode . java <nl> ppp IndexedLocationNode . java <nl> - if (indexScalingEnabled && tool . target() != null) { <nl> + if (indexScalingEnabled) { <nl> + if (tool . target() == null) { <nl> + return this ; <nl> + } <nl>,do not canonicalize scaled indexedlocation node if target be not available,1
9b26e0c5b2325ad0df150370cfd686072ec09fbe,2012-06-08 15:11:19+02:00,"mmm LoopEx . java <nl> ppp LoopEx . java <nl> + @Override <nl> + public String toString() { <nl> + return isCounted() ? ""Counted"" : """" ""Loop (depth="" lirLoop() . depth "") "" loopBegin() ; <nl> + } <nl> mmm LoopFragment . java <nl> ppp LoopFragment . java <nl> - FrameState state = exitState . duplicate() ; <nl> - merge . setStateAfter(state) ; <nl> + FrameState state = null ; <nl> + if (exitState != null) { <nl> + state = exitState . duplicate() ; <nl> + merge . setStateAfter(state) ; <nl> + } <nl> - state . replaceFirstInput(vpn, <nl>",fix problem with jython and tmt,0
da3442ca62ead1a5168d6b72e60d4f720f6b507d,2012-06-08 16:07:32+02:00,mmm Graal . java <nl> ppp Graal . java <nl> - private static GraalRuntime runtime ; <nl> - private static volatile boolean initialized ; <nl> + private static volatile GraalRuntime runtime ; <nl> - public static boolean hasRuntime() { <nl> - return getRuntime() != null ; <nl> - } <nl> - boolean wasInitialized = initialized ; <nl> - if (!wasInitialized) { <nl> + GraalRuntime oldValue = runtime ; <nl> + if (oldValue == null) { <nl> - if (!initialized) { <nl> + if (runtime == null) { <nl> - runtime = null ; <nl> + runtime = new GraalRuntime() <nl>,return graalruntime with no capability if vm do not support creation of graalruntime instance,1
e33a87ed23a291032aa6d0478ab33d817bb2caf4,2012-06-22 11:35:55+02:00,"mmm GraalCompiler . java <nl> ppp GraalCompiler . java <nl> - new LoopFullUnrollPhase() . apply(graph) ; <nl> + new LoopFullUnrollPhase(runtime) . apply(graph) ; <nl> mmm LoopTransformations . java <nl> ppp LoopTransformations . java <nl> + import com . oracle . graal . api . code . * ; <nl> - public static void fullUnroll(LoopEx loop) { <nl> + public static void fullUnroll(LoopEx loop, CodeCacheProvider runtime) { <nl> - new CanonicalizerPhase(null, null, null, mark, null) . apply(graph) ; <nl> + new CanonicalizerPhase(null, runtime, null, mark, null) . apply(graph) ; <nl> mmm LoopFullUnrollPhase . java <nl> ppp LoopFullUnrollPhase . java <nl> <nl>",do not try to fold condition when there be no runtime available,1
d87364019a8fa7abf53b69c90e5ff6e015e08876,2012-07-03 15:00:23+02:00,mmm ArrayCopySnippets . java <nl> ppp ArrayCopySnippets . java <nl> - for (long i = byteLength 1 ; i > byteLength 1 nonVectorBytes ; i--) { <nl> + for (long i = byteLength - arrayIndexScale(Kind . Byte) ; i >= byteLength - nonVectorBytes ; i -= arrayIndexScale(Kind . Byte)) { <nl> - for (long i = 0 ; i < nonVectorBytes ; i++) { <nl> + for (long i = 0 ; i < nonVectorBytes ; i += arrayIndexScale(Kind . Byte)) { <nl> - for (long i = byteLength 1 ; i > byteLength 1 nonVectorBytes ; i -= <nl>,fix aliased case problem intoduced in last array copy snippet,1
d381e11bd0ed9f7f4ec1b6311f3848ec64d29c26,2012-07-07 12:53:00+02:00,mmm InliningUtil . java <nl> ppp InliningUtil . java <nl> - while (current instanceof FixedWithNextNode) { <nl> - current = ((FixedWithNextNode) current) . next() ; <nl> + do { <nl> - } <nl> + current = ((FixedWithNextNode) current) . next() ; <nl> + } while (current instanceof FixedWithNextNode) ; <nl>,fix for npe in inliningutil,1
3d85c478568dc8fceb0a4e0635b6984ca7b3952e,2012-07-11 15:28:28+02:00,"mmm HotSpotDebugConfig . java <nl> ppp HotSpotDebugConfig . java <nl> - if (GraalOptions . PrintIdealGraphFile) { <nl> - dumpHandlers . add(new GraphPrinterDumpHandler()) ; <nl> - } else { <nl> - dumpHandlers . add(new GraphPrinterDumpHandler(GraalOptions . PrintIdealGraphAddress, GraalOptions . PrintBinaryGraphPort)) ; <nl> - } <nl> + dumpHandlers . add(new GraphPrinterDumpHandler()) ; <nl> mmm GraphPrinterDumpHandler . java <nl> ppp GraphPrinterDumpHandler . java <nl> - private List<String> previousInlineContext = new ArrayList<>() ; <nl> - private String host ; <nl> - private int port ; <nl> + private List<String> previousInlineContext ; <nl> - } <nl> - public GraphPrinterDumpHandler(String host, int port) { <nl> <nl>",make sure the right port be use for dump,1
a14baebf7d54aee36f5d9e9e12c085a17677eca5,2012-07-20 14:33:14+02:00,"mmm CanonicalizerPhase . java <nl> ppp CanonicalizerPhase . java <nl> - workList = graph . createNodeWorkList(newNodesMark == 0, MAX_ITERATION_PER_NODE) ; <nl> + workList = graph . createNodeWorkList(false, MAX_ITERATION_PER_NODE) ; <nl>",canonicalizer should not fill the worklist if an initial worklist be provide,1
7eba3c1ee1340123aa1ba624d3ecaef54673954d,2012-09-14 14:14:01-07:00,"mmm SnippetTemplate . java <nl> ppp SnippetTemplate . java <nl> - private final CodeCacheProvider runtime ; <nl> + private final MetaAccessProvider runtime ; <nl> - public Cache(CodeCacheProvider runtime) { <nl> + public Cache(MetaAccessProvider runtime) { <nl> - public SnippetTemplate(CodeCacheProvider runtime, SnippetTemplate . Key key) { <nl> + public SnippetTemplate(MetaAccessProvider runtime, SnippetTemplate . Key key) { <nl> - private IdentityHashMap<Node, Node> bind(StructuredGraph replaceeGraph, CodeCacheProvider runtime, SnippetTemplate . Arguments args) { <nl> + private IdentityHashMap<Node, Node> bind(StructuredGraph replaceeGraph, MetaAccessProvider runtime, SnippetTemplate . Arguments args) { <nl> - public Map<Node, Node> instantiate(CodeCacheProvider runtime, <nl> + public Map<Node, Node> instantiate(MetaAccessProvider runtime, <nl> - <nl>","snippet need only a metaaccessprovider , not a codecacheprovider",1
a75476eabd4e8edf8baa32eebdeb16272920277a,2012-09-25 09:21:52-07:00,"mmm MembarNode . java <nl> ppp MembarNode . java <nl> - public class MembarNode extends AbstractStateSplit implements StateSplit, LIRLowerable, MemoryCheckpoint { <nl> + public class MembarNode extends FixedWithNextNode implements LIRLowerable, MemoryCheckpoint { <nl>","membarnode do not need state and have no side effect , so it need not be a statesplit",1
f046304d2e9428357d2e8b269ca4e0306a4bdf05,2012-10-09 14:02:33+02:00,"mmm LoopEx . java <nl> ppp LoopEx . java <nl> - Debug . log(MetaUtil . format(""%H::%n"", Debug . contextLookup(ResolvedJavaMethod . class)) + "" : Reassociated %s into %s"", binary, result) ; <nl> + if (Debug . isLogEnabled()) { <nl> + Debug . log(MetaUtil . format(""%H::%n"", Debug . contextLookup(ResolvedJavaMethod . class)) "" : Reassociated %s into %s"", binary, result) ; <nl> + } <nl>",fix nullpointerexception when disable debug,1
b1115b14fd6b9806fccda36421f9096ec0397ade,2012-10-10 20:29:53-07:00,"mmm InstanceOfNode . java <nl> ppp InstanceOfNode . java <nl> + import com . oracle . graal . graph . * ; <nl> + @Override <nl> + public boolean verify() { <nl> + for (Node usage : usages()) { <nl> + assertTrue(usage instanceof IfNode || usage instanceof ConditionalNode, ""unsupported usage: "", usage) ; <nl> + } <nl> + return super . verify() ; <nl> + } <nl> mmm ConvertDeoptimizeToGuardPhase . java <nl> ppp ConvertDeoptimizeToGuardPhase . java <nl> + import com . oracle . graal . nodes . java . * ; <nl> + if (conditionNode instanceof InstanceOfNode) { <nl> <nl>",the lower currently do not support a fixguard a the usage of an instanceofnode,1
335c689b7b2f9c10c1577ce31c99cbc55756d0cf,2012-11-07 15:59:11+01:00,mmm OnStackReplacementPhase . java <nl> ppp OnStackReplacementPhase . java <nl> + if (graph . getEntryBCI() == StructuredGraph . INVOCATION_ENTRY_BCI) { <nl> + return ; <nl> + } <nl> - System . out . println("no OnStackReplacementNode generated") ; <nl> - System . out . println("osr with locks not supported") ; <nl>,fix for unnecessary bailoutexceptions in osr,1
16142cadb2a223436b177600fa5e276ec97e8c54,2012-11-07 17:48:02+01:00,"mmm InliningUtil . java <nl> ppp InliningUtil . java <nl> - graph . addBeforeFixed(invoke . node(), graph . add(new FixedGuardNode(graph . unique(new IsNullNode(firstParam)), DeoptimizationReason . ClassCastException, DeoptimizationAction . InvalidateReprofile, true, invoke . leafGraphId()))) ; <nl> + graph . addBeforeFixed(invoke . node(), graph . add(new FixedGuardNode(graph . unique(new IsNullNode(firstParam)), DeoptimizationReason . NullCheckException, DeoptimizationAction . InvalidateReprofile, true, invoke . leafGraphId()))) ; <nl>",fix inlining : null check guard should use reason nullcheckexception,1
df9449483e1532ce3aeb42e49f413627830097a3,2012-11-12 21:10:27+01:00,mmm HotSpotTypePrimitive . java <nl> ppp HotSpotTypePrimitive . java <nl> - return Modifier . ABSTRACT | Modifier . FINAL | Modifier . PUBLIC ; <nl> + return Modifier . FINAL | Modifier . PUBLIC ; <nl>,primitive type be not abstract,1
06245e8d7c81645f12a06352cd081857be8205e1,2012-11-27 11:08:02+01:00,"mmm HotSpotSignature . java <nl> ppp HotSpotSignature . java <nl> - type = HotSpotGraalRuntime . getInstance() . lookupType(arguments . get(index), (HotSpotResolvedJavaType) accessingClass, true) ; <nl> + type = HotSpotGraalRuntime . getInstance() . lookupType(arguments . get(index), (HotSpotResolvedJavaType) accessingClass, false) ; <nl> - if (returnTypeCache == null) { <nl> + if (returnTypeCache == null || !(returnTypeCache instanceof ResolvedJavaType)) { <nl>",hotspotsignature.getparametertype should not try eager resolving,1
41b691cc759ef8b8b17f57418a020de0ab101850,2012-11-30 11:22:50-08:00,"mmm AMD64LIRGenerator . java <nl> ppp AMD64LIRGenerator . java <nl> + @Override <nl> + public void visitBreakpointNode(BreakpointNode node) { <nl> + Kind[] sig = new Kind[node . arguments . size()] ; <nl> + for (int i = 0 ; i < sig . length ; i++) { <nl> + sig[i] = node . arguments . get(i) . kind() ; <nl> + } <nl> + CallingConvention cc = frameMap . registerConfig . getCallingConvention(CallingConvention . Type . JavaCall, Kind . Void, sig, target(), false) ; <nl> + Value[] parameters = visitInvokeArguments(cc, node . arguments) ; <nl> + append(new AMD64BreakpointOp(parameters)) ; <nl> <nl>","lir generation for breakpointnode be not hotspot specific and generally useful , so it should not be in hotspot project",1
ed3cc0b3f77934819225a87557c46f714cb8558f,2013-01-07 19:02:39-08:00,mmm Word . java <nl> ppp Word . java <nl> - @Operation(node = IntegerMulNode . class) <nl> + @Operation(node = IntegerDivNode . class) <nl> - @Operation(node = IntegerMulNode . class) <nl> + @Operation(node = IntegerDivNode . class) <nl>,fix wrong @ operation annotation,1
c4ac2da9951bf73f5d48d827d40bec3b87d498fc,2013-01-07 19:03:29-08:00,"mmm GraphOrder . java <nl> ppp GraphOrder . java <nl> + if (node instanceof LoopBeginNode) { <nl> + LoopBeginNode loopBegin = (LoopBeginNode) node ; <nl> + for (LoopEndNode loopEnd : loopBegin . loopEnds()) { <nl> + visitForward(visited, loopEnd) ; <nl> + } <nl> + } <nl>",graphorder do not process all node of loop,1
70d343e3fe3707f7c9248766e428e16edb287b67,2013-01-11 15:05:31+01:00,"mmm ArrayCopyIntrinsificationTest . java <nl> ppp ArrayCopyIntrinsificationTest . java <nl> + @Test <nl> + public void testObjectExact() { <nl> + Object[] src = {""one"", ""two"", ""three"", new ArrayList<>(), new HashMap<>()} ; <nl> + test(""exactObjectArraycopy"", (Object) src) ; <nl> + } <nl> + @Test <nl> + public void testString() { <nl> + String[] src = {""one"", ""two"", ""three""} ; <nl> + test(""stringArraycopy"", src, 0, new String[src . length], 0, src . length) ; <nl> + } <nl> + mustIntrinsify = false ; // a call to arraycopy where dest is not an exact type will not be intrinsified <nl> - <nl>",arraycopy can not be intrinsified if the destination array type be not exact,1
080defeb97e5fede960b8f75ace46186a7da1785,2013-01-15 11:10:59+01:00,mmm HotSpotSnippetInstaller . java <nl> ppp HotSpotSnippetInstaller . java <nl> - if (substituteMethod . getDeclaringClass() == IntegerSubstitutions . class) { <nl> + if (substituteMethod . getDeclaringClass() == IntegerSubstitutions . class || substituteMethod . getDeclaringClass() == LongSubstitutions . class) { <nl>,long.bitcount should also not be intrinsified if popcnt be miss,1
a68db217d8ee1e7505f145beb3f5770ed4dc31dc,2013-01-23 17:21:07+01:00,mmm TailDuplicationPhase . java <nl> ppp TailDuplicationPhase . java <nl> + import com . oracle . graal . nodes . spi . * ; <nl> + if (current instanceof VirtualizableAllocation) { <nl> + return false ; <nl> + } <nl>,do not tail duplicate allocation,0
33bf8cb187ad14d2fe9ee94cc66e4f74d2b07f77,2013-02-01 17:34:01+01:00,"mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> - IfNode ifNode = currentGraph . add(new IfNode(currentGraph . unique(new IsNullNode(receiver)), trueSucc, falseSucc, 0 . 5)) ; <nl> + IfNode ifNode = currentGraph . add(new IfNode(currentGraph . unique(new IsNullNode(receiver)), trueSucc, falseSucc, 0 . 1)) ; <nl> - IfNode ifNode = currentGraph . add(new IfNode(currentGraph . unique(new IntegerBelowThanNode(index, length)), trueSucc, falseSucc, 0 . 5)) ; <nl> + IfNode ifNode = currentGraph . add(new IfNode(currentGraph . unique(new IntegerBelowThanNode(index, length)), trueSucc, falseSucc, 0 . 9)) ; <nl>",fix probability for explicit npe and aioobe in graphbuilderphase,1
2375f3ea53c856a4a234fa23026b59b5ba1b5f86,2013-02-04 06:26:47-08:00,"mmm MetaUtil . java <nl> ppp MetaUtil . java <nl> - return classForNameCompatible ? name . replace('/',  ' . ') : internalNameToJava(name . substring(1), qualified, classForNameCompatible) + ""[]"" ; <nl> + return classForNameCompatible ? name . replace('/', ' . ') : internalNameToJava(name . substring(1), qualified, classForNameCompatible) ""[]"" ; <nl> + public static String signatureToMethodDescriptor(Signature sig) { <nl> + StringBuilder sb = new StringBuilder(""("") ; <nl> + for (int i = 0 ; i < sig . getParameterCount(false) ; ++i) { <nl> + sb . append(sig . getParameterType(i, null) . getName()) ; <nl> + } <nl> + sb . <nl>",getmethoddescriptor do not need to be in the signature interface,0
2b4c2d8f4ea20f808f33655a472c96bd61f32b6a,2013-02-08 15:59:43+01:00,"mmm NodeCodeGenerator . java <nl> ppp NodeCodeGenerator . java <nl> - if (!type . isVoid()) { <nl> - builder . startStatement() . type(specialization . getReturnType() . getActualType()) . string("" result"") . end() ; <nl> - } <nl> + ExecutableTypeData castedType = node . findExecutableType(type) ; <nl> - boolean needsTry = !specialization . getReturnType() . getActualTypeData(typeSystem) . isGeneric() ; <nl> + boolean needsTry = execType . hasUnexpectedValue(getContext()) ; <nl> + boolean returnVoid = type . isVoid() ; <nl> + CodeTree primaryExecuteCall = null ; <nl> + CodeTreeBuilder executeBuilder = CodeTreeBuilder . createBuilder() ; <nl> + buildExecute(executeBuilder, null, execType) ; <nl> <nl>",generate node can now handle the case be a non generic execute method do not throw an uve,1
65c731c14e589f1bad5262991bf83e1e6c0349f7,2013-02-11 14:21:18+01:00,"mmm GenerateOverrideVisitor . java <nl> ppp GenerateOverrideVisitor . java <nl> + import com . oracle . truffle . codegen . processor . * ; <nl> + for (AnnotationMirror mirror : e . getAnnotationMirrors()) { <nl> + if (Utils . typeEquals(overrideType, mirror . getAnnotationType())) { <nl> + return super . visitExecutable(e, p) ; <nl> + } <nl> + } <nl>",fix duplicate generation of @ override annotation,1
8870f0ae191f922b9c868f34495f574fe8337e4a,2013-02-11 16:20:52+01:00,mmm NodeCodeGenerator . java <nl> ppp NodeCodeGenerator . java <nl> + String name = specializationId(specialization) ; <nl> + name += nodeClassName(specialization . getNode()) ; <nl> + if (name . equals(Utils . getSimpleName(specialization . getNode() . getNodeType())) || name . equals(Utils . getSimpleName(specialization . getNode() . getTemplateType()))) { <nl> + name = name "Impl" ; <nl> + } <nl> + return name ; <nl> + } <nl> + private static String specializationId(SpecializationData specialization) { <nl> - name += nodeClassName(specialization . getNode()) ; <nl> - if (name . equals(Utils . getSimpleName(specialization . getNode() . getNodeType())) || name . equals(Utils . getSimpleName(specialization <nl>,fix rewrite in generated generic do not invoke guard,1
bc3f41eec87d32804791254cf655172814c05e60,2013-02-18 15:34:58+01:00,"mmm AssemblerTest . java <nl> ppp AssemblerTest . java <nl> - Assert . assertEquals(""unexpected return value: "" + actual, actual, expected) ; <nl> + Assert . assertEquals(""unexpected return value"", expected, actual) ; <nl>",fix error message,0
f8d943f85ee4b6d0a27254e1a0b588320745933f,2013-02-19 11:31:23+01:00,"mmm NodeCodeGenerator . java <nl> ppp NodeCodeGenerator . java <nl> - builder . startElseBlock() ; <nl> - builder . end() ; <nl> mmm TernaryNode . java <nl> ppp TernaryNode . java <nl> + @GuardCheck <nl> + public boolean demoIntegerGuard(boolean condition, boolean hasIfPart, int ifPart, boolean hasElsePart, int elsePart) { <nl> + return true ; <nl> + } <nl> + @SpecializationGuard(methodName = ""demoIntegerGuard"") <nl> + @SpecializationThrows(javaClass = RuntimeException . class, transitionTo = ""doBigInteger"") <nl>",fix generate generic do not need an else block,1
66a842672a0a504ffa651f76a3a1f7a687da4204,2013-02-25 13:04:24+01:00,"mmm NodeParser . java <nl> ppp NodeParser . java <nl> - log . error(originalType, ""No @%s annotation found in type hierarchy . "", TypeSystemReference . class . getSimpleName()) ; <nl> + log . error(type, ""No @%s annotation found in type hierarchy . "", TypeSystemReference . class . getSimpleName()) ; <nl> - log . error(originalType, ""The used type system '%s' is invalid . "", Utils . getQualifiedName(typeSytemType)) ; <nl> + log . error(type, ""The used type system '%s' is invalid . "", Utils . getQualifiedName(typeSytemType)) ; <nl> - parsedNodes . put(Utils . getQualifiedName(type), nodeData) ; // node fields will resolve <nl>",fix error message in parser,0
63021e3d5392c98a45836c065bd2d771b2f303f3,2013-03-20 11:32:41+01:00,"mmm ReadNode . java <nl> ppp ReadNode . java <nl> - return canonicalizeRead(this, tool) ; <nl> + return canonicalizeRead(this, location(), object(), tool) ; <nl> - public static ValueNode canonicalizeRead(Access read, CanonicalizerTool tool) { <nl> + public static ValueNode canonicalizeRead(ValueNode read, LocationNode location, ValueNode object, CanonicalizerTool tool) { <nl> - if (runtime != null && read . object() != null && read . object() . isConstant()) { <nl> - if (read . location() . locationIdentity() == LocationNode . FINAL_LOCATION && read . location() . getClass() == LocationNode . class) { <nl> - long displacement = read . location() . displacement() <nl>",do not use access interface in readnode.canonicalizeread,1
9045a370cfd821abbc252a8fcba30295ed728e54,2013-03-17 21:23:14+01:00,mmm GuardLoweringPhase . java <nl> ppp GuardLoweringPhase . java <nl> - SchedulePhase schedule = new SchedulePhase(SchedulePhase . SchedulingStrategy . EARLIEST) ; <nl> + SchedulePhase schedule = new SchedulePhase() ; <nl>,do not schedule early for guard lowering,0
1a55edee460863867953bfd911bb658d49b9b4a4,2013-03-16 16:11:40+01:00,mmm NodeParser . java <nl> ppp NodeParser . java <nl> + if (signature . isEmpty()) { <nl> + continue ; <nl> + } <nl> - for (String s : signatureChunk) { <nl> - b . append(s) ; <nl> + if (signatureChunk . isEmpty()) { <nl> + b . append("Default") ; <nl> + } else { <nl> + for (String s : signatureChunk) { <nl> + b . append(s) ; <nl> + } <nl>,fix not specialize node be name null instead of default,1
ba9d88289c5ef19ad6781ac59436b3b4f4ab88fd,2013-03-18 19:21:01-07:00,mmm LinearScan . java <nl> ppp LinearScan . java <nl> - if (isStackSlot(move . getInput()) && move . getInput() . getKind() != Kind . Object) { <nl> + if (optimizeMethodArgument(move . getInput())) { <nl> + private static boolean optimizeMethodArgument(Value value) { <nl> + return isStackSlot(value) && asStackSlot(value) . isInCallerFrame() && (GraalOptions . IncomingMethodArgumentsGCSafe || value . getKind() != Kind . Object) ; <nl> + } <nl> - if (isStackSlot(move . getInput()) && move . getInput() . getKind() != Kind . Object) { <nl> - StackSlot slot = (StackSlot) move . getInput() ; <nl> + if (optimizeMethodArgument(move . getInput())) { <nl>,only stack slot in caller frame be method argument also optimize object argument when the runtime support it,1
46b4822e19bfbeffaa2f41c6f07611ab12a5c04e,2013-03-19 15:38:10+01:00,"mmm AESCryptSubstitutions . java <nl> ppp AESCryptSubstitutions . java <nl> - @ClassSubstitution(className = ""com . sun . crypto . provider . AESCrypt"") <nl> + @ClassSubstitution(className = ""com . sun . crypto . provider . AESCrypt"", optional = true) <nl> mmm CipherBlockChainingSubstitutions . java <nl> ppp CipherBlockChainingSubstitutions . java <nl> - @ClassSubstitution(className = ""com . sun . crypto . provider . CipherBlockChaining"") <nl> + @ClassSubstitution(className = ""com . sun . crypto . provider . CipherBlockChaining"", optional = true) <nl> mmm ClassSubstitution . java <nl> ppp ClassSubstitution . java <nl> + boolean optional() default false ; <nl> mmm SnippetInstaller . java <nl>",support substitution for class that make not be part of the runtime,1
170c006844140f1e5fe13fa33228cf1758ac2770,2013-03-19 20:48:28+01:00,"mmm ConvertDeoptimizeToGuardPhase . java <nl> ppp ConvertDeoptimizeToGuardPhase . java <nl> + assert d . isAlive() ; <nl> - List<EndNode> ends = mergeNode . forwardEnds() . snapshot() ; <nl> - for (EndNode end : ends) { <nl> - if (!end . isDeleted()) { <nl> - BeginNode beginNode = findBeginNode(end) ; <nl> - if (!(beginNode instanceof MergeNode)) { <nl> - visitDeoptBegin(beginNode, deopt, graph) ; <nl> - } <nl> - } <nl> + List<BeginNode> begins = new ArrayList<>() ; <nl> + for (EndNode end : mergeNode . forwardEnds()) { <nl> + begins . add(findBeginNode(end)) ; <nl> - if (mergeNode . isDeleted()) { <nl>",fix a corner case when kill the control flow into a deoptimize node,1
91d20d56755e3c09679ac0334cf3955d9ee722b9,2013-03-19 11:30:58+01:00,"mmm NodeCodeGenerator . java <nl> ppp NodeCodeGenerator . java <nl> + CodeTree executeNode ; <nl> - CodeTree executeNode = createExecute(builder, specialization) ; <nl> + executeNode = createExecute(builder, specialization) ; <nl> - if (specialization . getMethod() == null && !node . needsRewrites(context)) { <nl> + if (specialization . isUninitialized()) { <nl> + String genericMethodName = generatedGenericMethodName(null) ; <nl> + builder . startReturn() . startCall(factoryClassName(node), genericMethodName) ; <nl> + builder . string(""this"") ; <nl> + addInternalValueParameterNames(builder, specialization, null, true, true) ; <nl> + builder . end() . end() ; <nl> + } else if (specialization . getMethod() == null && !node <nl>",uninitialized case produce wrong call to throw new unsuportedoperationexception,1
bebd2befaf5c6a7df1e120dc22a7a14771cf03fe,2013-03-22 15:09:38+01:00,"mmm ClassSubstitutionVerifier . java <nl> ppp ClassSubstitutionVerifier . java <nl> - if (!classSubstition . getAnnotationType() . equals(type)) { <nl> + if (type . getKind() != TypeKind . DECLARED) { <nl> + env . getMessager() . printMessage(Kind . ERROR, ""The provided class must be a declared type . "", sourceElement, classSubstition, typeValue) ; <nl> + return null ; <nl> + } <nl> + if (!classSubstition . getAnnotationType() . asElement() . equals(((DeclaredType) type) . asElement())) { <nl> - if (type . getKind() != TypeKind . DECLARED) { <nl> - env . getMessager() . printMessage(Kind . ERROR, ""The provided class must be <nl>",fix substitution verifier emit wrong error,1
2aa9eb546afe43d995bed6812a7d66068dde511c,2013-03-26 12:16:35+01:00,"mmm InliningUtil . java <nl> ppp InliningUtil . java <nl> - exceptionMerge . setStateAfter(exceptionEdge . stateAfter() . duplicateModified(invoke . stateAfter() . bci, true, Kind . Void, exceptionObjectPhi)) ; <nl> + exceptionMerge . setStateAfter(exceptionEdge . stateAfter() . duplicateModified(invoke . stateAfter() . bci, true, Kind . Object, exceptionObjectPhi)) ; <nl>",fix for polymorphic inlining after fuse exception obecjt and the distaptch begin,1
c0a54e509a28aa5d2cdacd0e72b3bca5853688d3,2013-04-05 11:03:21+02:00,mmm NodeParser . java <nl> ppp NodeParser . java <nl> + if (nodeData . hasErrors()) { <nl> + return nodeData ; // error sync point <nl> + } <nl> - if (nodeData . hasErrors()) { <nl> - return nodeData ; // error sync point <nl> - } <nl>,fix nodeparser error synchronization be do too late,1
60781ce3906ac6a76343eddd7a830795ec30a2cb,2013-04-06 16:26:19+02:00,"mmm Utils . java <nl> ppp Utils . java <nl> + public static boolean isObject(TypeMirror actualType) { <nl> + return getQualifiedName(actualType) . equals(""java . lang . Object"") ; <nl> + } <nl> mmm NodeCodeGenerator . java <nl> ppp NodeCodeGenerator . java <nl> - private CodeTree createTemplateMethodCall(CodeTreeBuilder parent, TemplateMethod sourceMethod, TemplateMethod targetMethod, String unexpectedValueName) { <nl> + private static CodeTree createTemplateMethodCall(CodeTreeBuilder parent, TemplateMethod sourceMethod, TemplateMethod targetMethod, String unexpectedValueName) { <nl> + ActualParameter sourceParameter = sourceMethod . findParameter(parameter . getLocalName()) ; <nl> - NodeData fieldNode = field . getNodeData() ; <nl> - ExecutableTypeData execType = fieldNode . findExecutableType(parameter . getActualTypeData(node . <nl>",fix user generic signature must not match generate generic signature,1
0044450bc38017308e7f7367ee3508ec3be8e95d,2013-04-06 16:30:23+02:00,mmm NodeParser . java <nl> ppp NodeParser . java <nl> - boolean hasErrors = rootNode != null ? rootNode . hasErrors() : false ; <nl> - if ((rootNode == null || hasErrors) && children . size() > 0) { <nl> + if (rootNode == null && children . size() > 0) { <nl>,fix rootnode should not get replace if an error occur otherwise no error be output,1
856ccb35c83a1e6a54dd5b653871cabb3969e2ec,2013-04-08 19:01:07+02:00,"mmm UnboxNode . java <nl> ppp UnboxNode . java <nl> - import com . oracle . graal . graph . Node . IterableNodeType ; <nl> - public class UnboxNode extends FixedWithNextNode implements VirtualizableAllocation, IterableNodeType, Lowerable, Canonicalizable { <nl> + public class UnboxNode extends FixedWithNextNode implements Virtualizable, Lowerable, Canonicalizable { <nl>",unboxnode be not a virtualizableallocation,1
4cec39f8f4740d198e97b4c28a0b5666b46cd497,2013-04-09 19:29:12+02:00,mmm RuntimeCallTarget . java <nl> ppp RuntimeCallTarget . java <nl> + boolean preservesRegisters() ; <nl> mmm HotSpotRuntimeCallTarget . java <nl> ppp HotSpotRuntimeCallTarget . java <nl> + @Override <nl> + public boolean preservesRegisters() { <nl> + return stub == null ; <nl> + } <nl> mmm AMD64Call . java <nl> ppp AMD64Call . java <nl> - public static class DirectCallOp extends AMD64LIRInstruction implements StandardOp . CallOp { <nl> + public static class DirectCallOp extends AMD64LIRInstruction { <nl> + @Override <nl> + public boolean hasCall() { <nl> + return true ; <nl> + } <nl> - public static class DirectNearRuntimeCallOp extends <nl>,runtime call that do not destroy the caller 's register need no spilling at the call site,1
fe2ba2f084f4241aa5a79fd9e9035d10c8e65dcf,2013-04-11 18:37:26+02:00,"mmm TailDuplicationPhase . java <nl> ppp TailDuplicationPhase . java <nl> - retargetDependencies(duplicatedNodes, anchor) ; <nl> - private static void retargetDependencies(HashSet<Node> duplicatedNodes, ValueAnchorNode anchor) { <nl> - for (Node node : duplicatedNodes) { <nl> - if (node instanceof ValueNode) { <nl> - NodeInputList<ValueNode> dependencies = ((ValueNode) node) . dependencies() ; <nl> - for (int i = 0 ; i < dependencies . size() ; i++) { <nl> - Node dependency = dependencies . get(i) ; <nl> - if (dependency != null && !duplicatedNodes . contains(dependency)) { <nl> - Debug . log(""retargeting dependency %s to %s on %s"", dependency, anchor, node) <nl>",fix errorneous handling of valueanchornodes in tailduplicationphase,0
a89b148945e661c190d35038f41b5ce7b9d2437d,2013-04-11 14:26:54-07:00,mmm InvokeNode . java <nl> ppp InvokeNode . java <nl> + if (stateAfter == null) { <nl> + return null ; <nl> + } <nl> - return true ; <nl> + return stateAfter() != null ; <nl>,a invoke without a state can not deoptimize,0
4c5d3eb4d84071745c3340584a76f0ebef61968a,2013-04-23 21:03:47+02:00,"mmm IsNullNode . java <nl> ppp IsNullNode . java <nl> + import com . oracle . graal . nodes . type . * ; <nl> - replaceFirstInput(parent, parent . object()) ; <nl> - return true ; <nl> + ObjectStamp piStamp = parent . objectStamp() ; <nl> + ObjectStamp piValueStamp = parent . object() . objectStamp() ; <nl> + if (piStamp . nonNull() == piValueStamp . nonNull() && piStamp . alwaysNull() == piValueStamp . alwaysNull()) { <nl> + replaceFirstInput(parent, parent . object()) ; <nl> + return true ; <nl> + } else { <nl> + return false ; <nl> + <nl>",do not pushthroughpi if nullness before/after pi differs,1
e6d5ed9f80476401cdb6b0424e96cf11d293f942,2013-04-27 20:17:10+02:00,mmm IfNode . java <nl> ppp IfNode . java <nl> - if (falseSuccessor() . usages() . isEmpty() && falseSuccessor() . next() instanceof IfNode) { <nl> + if (falseSuccessor() . usages() . isEmpty() && (!(falseSuccessor() instanceof LoopExitNode)) && falseSuccessor() . next() instanceof IfNode) { <nl> + if (compareA . unorderedIsTrue()) { <nl> + return false ; <nl> + } <nl> + if (compareB . unorderedIsTrue()) { <nl> + return false ; <nl> + } <nl>,do not swap if node when there be a loop exit node between them do not swap if one of the compare have unorderedistrue set,1
bf5ad4bd4a517072fc440fcedba2602beae721c3,2013-04-28 01:01:00+02:00,mmm IfNode . java <nl> ppp IfNode . java <nl> - if (instanceOfA . profile() . getNullSeen() != TriState . FALSE) { <nl> + if (instanceOfA . profile() != null && instanceOfA . profile() . getNullSeen() != TriState . FALSE) { <nl>,fix null pointer exception in if reordering,0
